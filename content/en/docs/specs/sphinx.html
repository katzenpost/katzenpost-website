---
title: "Sphinx Specification"
linkTitle: "Sphinx"
draft: false
slug: "/sphinx/"
---

<p><strong>Abstract</strong></p>
<p>This document defines the Sphinx cryptographic packet format for
decryption mix networks, and provides a parameterization based around
generic cryptographic primitives types. This document does not introduce
any new crypto, but is meant to serve as an implementation guide.</p>
<h1 id="introduction">1. Introduction</h1>
<p>The Sphinx cryptographic packet format is a compact and provably
secure design introduced by George Danezis and Ian Goldberg <a
href="#SPHINX09">SPHINX09</a>. It supports a full set of security
features: indistinguishable replies, hiding the path length and relay
position, detection of tagging attacks and replay attacks, as well as
providing unlinkability for each leg of the packet’s journey over the
network.</p>
<h2 id="terminology">1.1 Terminology</h2>
<ul>
<li><code>Message</code> - A variable-length sequence of octets sent
anonymously through the network.</li>
<li><code>Packet</code> - A fixed-length sequence of octets transmitted
anonymously through the network, containing the encrypted message and
metadata for routing.</li>
<li><code>Header</code> - The packet header consisting of several
components, which convey the information necessary to verify packet
integrity and correctly process the packet.</li>
<li><code>Payload</code> - The fixed-length portion of a packet
containing an encrypted message or part of a message, to be delivered
anonymously.</li>
<li><code>Group</code> - A finite set of elements and a binary operation
that satisfy the properties of closure, associativity, invertability,
and the presence of an identity element.</li>
<li><code>Group element</code> - An individual element of the
group.</li>
<li><code>Group generator</code> - A group element capable of generating
any other element of the group, via repeated applications of the
generator and the group operation.</li>
</ul>
<h2 id="conventions-used-in-this-document">1.2 Conventions Used in This
Document</h2>
<p>The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”,
“SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this
document are to be interpreted as described in <a
href="#RFC2119">RFC2119</a>.</p>
<p>The “C” style Presentation Language as described in <a
href="#RFC5246">RFC5246</a> Section 4 is used to represent data
structures, except for cryptographic attributes, which are specified as
opaque byte vectors.</p>
<ul>
<li><code>x | y</code> denotes the concatenation of x and y.</li>
<li><code>x ^ y</code> denotes the bitwise XOR of x and y.</li>
<li><code>byte</code> an 8-bit octet.</li>
<li><code>x[a:b]</code> denotes the sub-vector of x where a/b denote the
start/end byte indexes (inclusive-exclusive); a/b may be omitted to
signify the start/end of the vector x respectively.</li>
<li><code>x[y]</code> denotes the y'th element of list x.</li>
<li><code>x.len</code> denotes the length of list x.</li>
<li><code>ZEROBYTES(N)</code> denotes N bytes of 0x00.</li>
<li><code>RNG(N)</code> denotes N bytes of cryptographic random
data.</li>
<li><code>LEN(N)</code> denotes the length in bytes of N.</li>
<li><code>CONSTANT_TIME_CMP(x, y)</code> denotes a constant time
comparison between the byte vectors x and y, returning true iff x and y
are equal.</li>
</ul>
<h1 id="cryptographic-primitives">2. Cryptographic Primitives</h1>
<p>This specification uses the following cryptographic primitives as the
foundational building blocks for Sphinx:</p>
<ul>
<li><p><code>H(M)</code> - A cryptographic hash function which takes an
octet array M to produce a digest consisting of a
<code>HASH_LENGTH</code> byte octet array. <code>H(M)</code> MUST be
pre-image and collision resistant.</p></li>
<li><p><code>MAC(K, M)</code> - A cryptographic message authentication
code function which takes a <code>M_KEY_LENGTH</code> byte octet array
key <code>K</code> and arbitrary length octet array message
<code>M</code> to produce an authentication tag consisting of a
<code>MAC_LENGTH</code> byte octet array.</p></li>
<li><p><code>KDF(SALT, IKM)</code> - A key derivation function which
takes an arbitrary length octet array salt <code>SALT</code> and an
arbitrary length octet array initial key <code>IKM</code>, to produce an
octet array of arbitrary length.</p></li>
<li><p><code>S(K, IV)</code> - A pseudo-random generator (stream cipher)
which takes a <code>S_KEY_LENGTH</code> byte octet array key
<code>K</code> and a <code>S_IV_LENGTH</code> byte octet array
initialization vector <code>IV</code> to produce an octet array key
stream of arbitrary length.</p></li>
<li><p><code>SPRP_Encrypt(K, M)/SPRP_Decrypt(K, M)</code> - A strong
pseudo-random permutation (SPRP) which takes a
<code>SPRP_KEY_LENGTH</code> byte octet array key <code>K</code> and
arbitrary length message <code>M</code>, and produces the encrypted
ciphertext or decrypted plaintext respectively.</p>
<p>When used with the default payload authentication mechanism, the SPRP
MUST be "fragile" in that any amount of modifications to <code>M</code>
results in a large number of unpredictable changes across the whole
message upon a <code>SPRP_Encrypt()</code> or
<code>SPRP_Decrypt()</code> operation.</p></li>
<li><p><code>EXP(X, Y)</code> - An exponentiation function which takes
the <code>GROUP_ELEMENT_LENGTH</code> byte octet array group elements
<code>X</code> and <code>Y</code>, and returns <code>X ^^ Y</code> as a
<code>GROUP_ELEMENT_LENGTH</code> byte octet array.</p>
<p>Let <code>G</code> denote the generator of the group, and
<code>EXP_KEYGEN()</code> return a <code>GROUP_ELEMENT_LENGTH</code>
byte octet array group element usable as private key.</p>
<p>The group defined by <code>G</code> and <code>EXP(X, Y)</code> MUST
satisfy the Decision Diffie-Hellman problem.</p></li>
<li><p><code>EXP_KEYGEN()</code> - Returns a new "suitable" private key
for <code>EXP()</code>.</p></li>
</ul>
<h2 id="sphinx-key-derivation-function">2.1 Sphinx Key Derivation
Function</h2>
<p>Sphinx Packet creation and processing uses a common Key Derivation
Function (KDF) to derive the required MAC and symmetric cryptographic
keys from a per-hop shared secret.</p>
<p>The output of the KDF is partitioned according to the following
structure:</p>
<pre><code>struct {
    opaque header_mac[M_KEY_LENGTH];
    opaque header_encryption[S_KEY_LENGTH];
    opaque header_encryption_iv[S_IV_LENGTH];
    opaque payload_encryption[SPRP_KEY_LENGTH]
    opaque blinding_factor[GROUP_ELEMENT_LENGTH];
} SphinxPacketKeys;

Sphinx_KDF( info, shared_secret ) -&gt; packet_keys</code></pre>
<p>Inputs:</p>
<ul>
<li><code>info</code> The optional context and application specific
information.</li>
<li><code>shared_secret</code> The per-hop shared secret derived from
the Diffie-Hellman key exchange.</li>
</ul>
<p>Outputs:</p>
<ul>
<li><code>packet_keys</code> The SphinxPacketKeys required to handle
packet creation or processing.</li>
</ul>
<p>The output packet_keys is calculated as follows:</p>
<pre><code>kdf_out = KDF( info, shared_secret )
packet_keys = kdf_out[:LEN( SphinxPacketKeys )]</code></pre>
<h1 id="sphinx-packet-parameters">3. Sphinx Packet Parameters</h1>
<h2 id="sphinx-parameter-constants">3.1 Sphinx Parameter Constants</h2>
<p>The Sphinx Packet Format is parameterized by the implementation based
on the application and security requirements.</p>
<ul>
<li><code>AD_LENGTH</code> - The constant amount of per-packet
unencrypted additional data in bytes.</li>
<li><code>PAYLOAD_TAG_LENGTH</code> - The length of the message payload
authentication tag in bytes. This SHOULD be set to at least 16 bytes
(128 bits).</li>
<li><code>PER_HOP_RI_LENGTH</code> - The length of the per-hop Routing
Information (<code>Section 4.1.1 &lt;4.1.1&gt;</code>) in bytes.</li>
<li><code>NODE_ID_LENGTH</code> - The node identifier length in
bytes.</li>
<li><code>RECIPIENT_ID_LENGTH</code> - The recipient identifier length
in bytes.</li>
<li><code>SURB_ID_LENGTH</code> - The Single Use Reply Block
(<code>Section 7 &lt;7.0&gt;</code>) identifier length in bytes.</li>
<li><code>MAX_HOPS</code> - The maximum number of hops a packet can
traverse.</li>
<li><code>PAYLOAD_LENGTH</code> - The per-packet message payload length
in bytes, including a <code>PAYLOAD_TAG_LENGTH</code> byte
authentication tag.</li>
<li><code>KDF_INFO</code> - A constant opaque byte vector used as the
info parameter to the KDF for the purpose of domain separation.</li>
</ul>
<h2 id="sphinx-packet-geometry">3.2 Sphinx Packet Geometry</h2>
<p>The Sphinx Packet Geometry is derived from the Sphinx Parameter
Constants <code>Section 3.1</code>. These are all derived parameters,
and are primarily of interest to implementors.</p>
<ul>
<li><code>ROUTING_INFO_LENGTH</code> - The total length of the "routing
information" Sphinx Packet Header component in bytes:</li>
</ul>
<pre><code>ROUTING_INFO_LENGTH = PER_HOP_RI_LENGTH * MAX_HOPS</code></pre>
<ul>
<li><code>HEADER_LENGTH</code> - The length of the Sphinx Packet Header
in bytes:</li>
</ul>
<pre><code>HEADER_LENGTH = AD_LENGTH + GROUP_ELEMENT_LENGTH + ROUTING_INFO_LENGTH + MAC_LENGTH</code></pre>
<ul>
<li><code>PACKET_LENGTH</code> - The length of the Sphinx Packet in
bytes:</li>
</ul>
<pre><code>PACKET_LENGTH = HEADER_LENGTH + PAYLOAD_LENGTH</code></pre>
<h1 id="the-sphinx-cryptographic-packet-structure">4. The Sphinx
Cryptographic Packet Structure</h1>
<p>Each Sphinx Packet consists of two parts: the Sphinx Packet Header
and the Sphinx Packet Payload:</p>
<pre><code>struct {
    opaque header[HEADER_LENGTH];
    opaque payload[PAYLOAD_LENGTH];
} SphinxPacket;</code></pre>
<ul>
<li><code>header</code> - The packet header consists of several
components, which convey the information necessary to verify packet
integrity and correctly process the packet.</li>
<li><code>payload</code> - The application message data.</li>
</ul>
<h2 id="sphinx-packet-header">4.1 Sphinx Packet Header</h2>
<p>The Sphinx Packet Header refers to the block of data immediately
preceding the Sphinx Packet Payload in a Sphinx Packet.</p>
<p>The structure of the Sphinx Packet Header is defined as follows:</p>
<pre><code>struct {
    opaque additional_data[AD_LENGTH]; /* Unencrypted. */
    opaque group_element[GROUP_ELEMENT_LENGTH];
    opaque routing_information[ROUTING_INFO_LENGTH];
    opaque MAC[MAC_LENGTH];
} SphinxHeader;</code></pre>
<ul>
<li><p><code>additional_data</code> - Unencrypted per-packet Additional
Data (AD) that is visible to every hop. The AD is authenticated on a
per-hop basis.</p>
<p>As the additional_data is sent in the clear and traverses the network
unaltered, implementations MUST take care to ensure that the field
cannot be used to track individual packets.</p></li>
<li><p><code>group_element</code> - An element of the cyclic group, used
to derive the per-hop key material required to authenticate and process
the rest of the SphinxHeader and decrypt a single layer of the Sphinx
Packet Payload encryption.</p></li>
<li><p><code>routing_information</code> - A vector of per-hop routing
information, encrypted and authenticated in a nested manner. Each
element of the vector consists of a series of routing commands,
specifying all of the information required to process the packet.</p>
<p>The precise encoding format is specified in
<code>Section 4.1.1 &lt;4.1.1&gt;</code>.</p></li>
<li><p><code>MAC</code> - A message authentication code tag covering the
additional_data, group_element, and routing_information.</p></li>
</ul>
<h2 id="per-hop-routing-information">4.1.1 Per-hop routing
information</h2>
<p>The routing_information component of the Sphinx Packet Header
contains a vector of per-hop routing information. When processing a
packet, the per hop processing is set up such that the first element in
the vector contains the routing commands for the current hop.</p>
<p>The structure of the routing information is as follows:</p>
<pre><code>struct {
    RoutingCommand routing_commands&lt;1..2^8-1&gt;; /* PER_HOP_RI_LENGTH bytes */
    opaque encrypted_routing_commands[ROUTING_INFO_LENGTH - PER_HOP_RI_LENGTH];
} RoutingInformation;</code></pre>
<p>The structure of a single routing command is as follows:</p>
<pre><code>struct {
    RoutingCommandType command;
    select (RoutingCommandType) {
        case null:               NullCommand;
        case next_node_hop:      NextNodeHopCommand;
        case recipient:          RecipientCommand;
        case surb_reply:         SURBReplyCommand;
    };
} RoutingCommand;</code></pre>
<p>The following routing commands are currently defined:</p>
<pre><code>enum {
    null(0),
    next_node_hop(1),
    recipient(2),
    surb_reply(3),

    /* Routing commands between 0 and 0x7f are reserved. */

    (255)
} RoutingCommandType;</code></pre>
<p>The null routing command structure is as follows:</p>
<pre><code>struct {
    opaque padding&lt;0..PER_HOP_RI_LENGTH-1&gt;;
} NullCommand;</code></pre>
<p>The next_node_hop command structure is as follows:</p>
<pre><code>struct {
    opaque next_hop[NODE_ID_LENGTH];
    opaque MAC[MAC_LENGTH];
} NextNodeHopCommand;</code></pre>
<p>The recipient command structure is as follows:</p>
<pre><code>struct {
    opaque recipient[RECIPEINT_ID_LENGTH];
} RecipientCommand;</code></pre>
<p>The surb_reply command structure is as follows:</p>
<pre><code>struct {
    opaque id[SURB_ID_LENGTH];
} SURBReplyCommand;</code></pre>
<p>While the <code>NullCommand</code> padding field is specified as
opaque, implementations SHOULD zero fill the padding. The choice of
<code>0x00</code> as the terminal NullCommand is deliberate to ease
implementation, as <code>ZEROBYTES(N)</code> produces a valid
NullCommand RoutingCommand, resulting in “appending zero filled padding”
producing valid output.</p>
<p>Implementations MUST pad the routing_commands vector so that it is
exactly <code>PER_HOP_RI_LENGTH</code> bytes, by appending a terminal
NullCommand if necessary.</p>
<p>Every non-terminal hop’s <code>routing_commands</code> MUST include a
<code>NextNodeHopCommand</code>.</p>
<h2 id="sphinx-packet-payload">4.2 Sphinx Packet Payload</h2>
<p>The Sphinx Packet Payload refers to the block of data immediately
following the Sphinx Packet Header in a Sphinx Packet.</p>
<p>For most purposes the structure of the Sphinx Packet Payload can be
treated as a single contiguous byte vector of opaque data.</p>
<p>Upon packet creation, the payload is repeatedly encrypted (unless it
is a SURB Reply, see <code>Section 7.0</code> via keys derived from the
Diffie-Hellman key exchange between the packet's
<code>group_element</code> and the public key of each node in the
path.</p>
<p>Authentication of packet integrity is done by prepending a tag set to
a known value to the plaintext prior to the first encrypt operation. By
virtue of the fragile nature of the SPRP function, any alteration to the
encrypted payload as it traverses the network will result in an
irrecoverably corrupted plaintext when the payload is decrypted by the
recipient.</p>
<h1 id="sphinx-packet-creation">5. Sphinx Packet Creation</h1>
<p>For the sake of brevity, the pseudocode for all of the operations
will take a vector of the following PathHop structure as a parameter
named path[] to specify the path a packet will traverse, along with the
per-hop routing commands and per-hop public keys.</p>
<pre><code>struct {
    /* There is no need for a node_id here, as
       routing_commands[0].next_hop specifies that
       information for all non-terminal hops. */
    opaque public_key[GROUP_ELEMENT_LENGTH];
    RoutingCommand routing_commands&lt;1...2^8-1&gt;;
} PathHop;</code></pre>
<p>It is assumed that each routing_commands vector except for the
terminal entry contains at least a RoutingCommand consisting of a
partially assembled NextNodeHopCommand with the <code>next_hop</code>
element filled in with the identifier of the next hop.</p>
<h2 id="create-a-sphinx-packet-header">5.1 Create a Sphinx Packet
Header</h2>
<p>Both the creation of a Sphinx Packet and the creation of a SURB
requires the generation of a Sphinx Packet Header, so it is specified as
a distinct operation.</p>
<pre><code>Sphinx_Create_Header( additional_data, path[] ) -&gt; sphinx_header,
                                                   payload_keys</code></pre>
<p>Inputs:</p>
<ul>
<li><code>additional_data</code> The Additional Data that is visible to
every node along the path in the header.</li>
<li><code>path</code> The vector of PathHop structures in hop order,
specifying the node id, public key, and routing commands for each
hop.</li>
</ul>
<p>Outputs: <code>sphinx_header</code> The resulting Sphinx Packet
Header.</p>
<ul>
<li><code>payload_keys</code> The vector of SPRP keys used to encrypt
the Sphinx Packet Payload, in hop order.</li>
</ul>
<p>The <code>Sphinx_Create_Header</code> operation consists of the
following steps:</p>
<ol type="1">
<li>Derive the key material for each hop.</li>
</ol>
<pre><code>num_hops = route.len
route_keys = [ ]
route_group_elements = [ ]
priv_key = EXP_KEYGEN()

/* Calculate the key material for the 0th hop. */
group_element = EXP( G, priv_key )
route_group_elements += group_element
shared_secret = EXP( path[0].public_key, priv_key )
route_keys += Sphinx_KDF( KDF_INFO, shared_secret )
blinding_factor = keys[0].blinding_factor

/* Calculate the key material for rest of the hops. */
for i = 1; i &lt; num_hops; ++i:
    shared_secret = EXP( path[i].public_key, priv_key )
    for j = 0; j &lt; i; ++j:
        shared_secret = EXP( shared_secret, keys[j].blinding_factor )
    route_keys += Sphinx_KDF( KDF_INFO, shared_secret )
    group_element = EXP( group_element, keys[i-1].blinding_factor )
    route_group_elements += group_element</code></pre>
<p>At the conclusion of the derivation process:</p>
<ul>
<li><code>route_keys</code> - A vector of per-hop SphinxKeys.</li>
<li><code>route_group_elements</code> - A vector of per-hop group
elements.</li>
</ul>
<ol start="2" type="1">
<li>Derive the routing_information keystream and encrypted padding for
each hop.</li>
</ol>
<pre><code>ri_keystream = [ ]
ri_padding = [ ]

for i = 0; i &lt; num_hops; ++i:
    keystream = ZEROBYTES( ROUTING_INFO_LENGTH + PER_HOP_RI_LENGTH ) ^
                  S( route_keys[i].header_encryption,
                     route_keys[i].header_encryption_iv )
    ks_len = LEN( keystream ) - (i + 1) * PER_HOP_RI_LENGTH

    padding = keystream[ks_len:]
    if i &gt; 0:
        prev_pad_len = LEN( ri_padding[i-1] )
        padding = padding[:prev_pad_len] ^ ri_padding[i-1] |
            padding[prev_pad_len]

    ri_keystream += keystream[:ks_len]
    ri_padding += padding

At the conclusion of the derivation process:
   ri_keystream - A vector of per-hop routing_information
                  encryption keystreams.
   ri_padding   - The per-hop encrypted routing_information
                  padding.</code></pre>
<ol start="3" type="1">
<li>Create the routing_information block.</li>
</ol>
<pre><code>/* Start with the terminal hop, and work backwards. */
i = num_hops - 1

/* Encode the terminal hop&#39;s routing commands. As the
   terminal hop can never have a NextNodeHopCommand, there
   are no per-hop alterations to be made. */
ri_fragment = path[i].routing_commands |
   ZEROBYTES( PER_HOP_RI_LENGTH - LEN( path[i].routing_commands ) )

/* Encrypt and MAC. */
ri_fragment ^= ri_keystream[i]
mac = MAC( route_keys[i].header_mac, additional_data |
               route_group_elements[i] | ri_fragment |
               ri_padding[i-1] )
routing_info = ri_fragment
if num_hops &lt; MAX_HOPS:
    pad_len = (MAX_HOPS - num_hops) * PER_HOP_RI_LENGTH
    routing_info = routing_info | RNG( pad_len )

/* Calculate the routing info for the rest of the hops. */
for i = num_hops - 2; i &gt;= 0; --i:
    cmds_to_encode = [ ]

    /* Find and finalize the NextNodeHopCommand. */
    for j = 0; j &lt; LEN( path[i].routing_commands; j++:
        cmd = path[i].routing_commands[j]
        if cmd.command == next_node_hop:
          /* Finalize the NextNodeHopCommand. */
          cmd.MAC = mac
        cmds_to_encode = cmds_to_encode + cmd /* Append */

    /* Append a terminal NullCommand. */
    ri_fragment = cmds_to_encode |
        ZEROBYTES( PER_HOP_RI_LENGTH - LEN( cmds_to_encode ) )

    /* Encrypt and MAC */
    routing_info = ri_fragment | routing_info /* Prepend. */
    routing_info ^= ri_keystream[i]
    if i &gt; 0:
        mac = MAC( route_keys[i].header_mac, additional_data |
                   route_group_elements[i] | routing_info |
                   ri_padding[i-1] )
    else:
        mac = MAC( route_keys[i].header_mac, additional_data |
                   route_group_elements[i] | routing_info )

At the conclusion of the derivation process:
   routing_info - The completed routing_info block.
   mac          - The MAC for the 0th hop.</code></pre>
<ol start="4" type="1">
<li>Assemble the completed Sphinx Packet Header and Sphinx Packet
Payload SPRP key vector.</li>
</ol>
<pre><code>/* Assemble the completed Sphinx Packet Header. */
SphinxHeader sphinx_header
sphinx_header.additional_data = additional_data
sphinx_header.group_element = route_group_elements[0] /* From step 1. */
sphinx_header.routing_info = routing_info   /* From step 3. */
sphinx_header.mac = mac                     /* From step 3. */

/* Preserve the Sphinx Payload SPRP keys, to return to the
   caller. */
payload_keys = [ ]
for i = 0; i &lt; nr_hops; ++i:
    payload_keys += route_keys[i].payload_encryption

At the conclusion of the assembly process:
   sphinx_header - The completed sphinx_header, to be returned.
   payload_keys  - The vector of SPRP keys, to be returned.</code></pre>
<h2 id="create-a-sphinx-packet">5.2 Create a Sphinx Packet</h2>
<pre><code>Sphinx_Create_Packet( additional_data, path[], payload ) -&gt; sphinx_packet</code></pre>
<p>Inputs:</p>
<ul>
<li><code>additional_data</code> The Additional Data that is visible to
every node along the path in the header.</li>
<li><code>path</code> The vector of PathHop structures in hop order,
specifying the node id, public key, and routing commands for each
hop.</li>
<li><code>payload</code> The packet payload message plaintext.</li>
</ul>
<p>Outputs:</p>
<ul>
<li><code>sphinx_packet</code> The resulting Sphinx Packet.</li>
</ul>
<p>The <code>Sphinx_Create_Packet</code> operation consists of the
following steps:</p>
<ol type="1">
<li>Create the Sphinx Packet Header and SPRP key vector.</li>
</ol>
<pre><code>sphinx_header, payload_keys =
    Sphinx_Create_Header( additional_data, path )</code></pre>
<ol start="2" type="1">
<li>Prepend the authentication tag, and append padding to the
payload.</li>
</ol>
<pre><code>payload = ZERO_BYTES( PAYLOAD_TAG_LENGTH ) | payload
payload = payload | ZERO_BYTES( PAYLOAD_LENGTH - LEN( payload ) )</code></pre>
<ol start="3" type="1">
<li>Encrypt the payload.</li>
</ol>
<pre><code>for i = nr_hops - 1; i &gt;= 0; --i:
    payload = SPRP_Encrypt( payload_keys[i], payload )</code></pre>
<ol start="4" type="1">
<li>Assemble the completed Sphinx Packet.</li>
</ol>
<pre><code>SphinxPacket sphinx_packet
sphinx_packet.header = sphinx_header
sphinx_packet.payload = payload</code></pre>
<h1 id="sphinx-packet-processing">6. Sphinx Packet Processing</h1>
<p>Mix nodes process incoming packets first by performing the
<code>Sphinx_Unwrap</code> operation to authenticate and decrypt the
packet, and if applicable prepare the packet to be forwarded to the next
node.</p>
<p>If <code>Sphinx_Unwrap</code> returns an error for any given packet,
the packet MUST be discarded with no additional processing.</p>
<p>After a packet has been unwrapped successfully, a replay detection
tag is checked to ensure that the packet has not been seen before. If
the packet is a replay, the packet MUST be discarded with no additional
processing.</p>
<p>The routing commands for the current hop are interpreted and
executed, and finally the packet is forwarded to the next mix node over
the network or presented to the application if the current node is the
final recipient.</p>
<h2 id="sphinx_unwrap-operation">6.1 Sphinx_Unwrap Operation</h2>
<p>The <code>Sphinx_Unwrap</code> operation is the majority of the
per-hop packet processing, handling authentication, decryption, and
modifying the packet prior to forwarding it to the next node.</p>
<pre><code>Sphinx_Unwrap( routing_private_key, sphinx_packet ) -&gt; sphinx_packet,
                                                      routing_commands,
                                                      replay_tag</code></pre>
<p>Inputs:</p>
<ul>
<li><code>private_routing_key</code> A group element
GROUP_ELEMENT_LENGTH bytes in length, that serves as the unwrapping
Mix’s private key.</li>
<li><code>sphinx_packet</code> A Sphinx packet to unwrap.</li>
</ul>
<p>Outputs:</p>
<ul>
<li><code>error</code> Indicating a unsuccessful unwrap operation if
applicable.</li>
<li><code>sphinx_packet</code> The resulting Sphinx packet.</li>
<li><code>routing_commands</code> A vector of RoutingCommand, specifying
the post unwrap actions to be taken on the packet.</li>
<li><code>replay_tag</code> A tag used to detect whether this packet was
processed before.</li>
</ul>
<p>The <code>Sphinx_Unwrap</code> operation consists of the following
steps:</p>
<ol start="0" type="1">
<li>(Optional) Examine the Sphinx Packet Header’s Additional Data.</li>
</ol>
<p>If the header’s <code>additional_data</code> element contains
information required to complete the unwrap operation, such as
specifying the packet format version or the cryptographic primitives
used examine it now.</p>
<p>Implementations MUST NOT treat the information in the
<code>additional_data</code> element as trusted until after the
completion of Step 3 (“Validate the Sphinx Packet Header”).</p>
<ol type="1">
<li>Calculate the hop's shared secret, and replay_tag.</li>
</ol>
<pre><code>hdr = sphinx_packet.header
shared_secret = EXP( hdr.group_element, private_routing_key )
replay_tag = H( shared_secret )</code></pre>
<ol start="2" type="1">
<li>Derive the various keys required for packet processing.</li>
</ol>
<pre><code>keys = Sphinx_KDF( KDF_INFO, shared_secret )</code></pre>
<ol start="3" type="1">
<li>Validate the Sphinx Packet Header.</li>
</ol>
<pre><code>derived_mac = MAC( keys.header_mac, hdr.additional_data |
                  hdr.group_element |
                  hdr.routing_information )
if !CONSTANT_TIME_CMP( derived_mac, hdr.MAC):
    /* MUST abort processing if the header is invalid. */
    return ErrorInvalidHeader</code></pre>
<ol start="4" type="1">
<li>Extract the per-hop routing commands for the current hop.</li>
</ol>
<pre><code>/* Append padding to preserve length-invariance, as the routing
    commands for the current hop will be removed. */
padding = ZEROBYTES( PER_HOP_RI_LENGTH )
B = hdr.routing_information | padding

/* Decrypt the entire routing_information block. */
B = B ^ S( keys.header_encryption, keys.header_encryption_iv )</code></pre>
<ol start="5" type="1">
<li>Parse the per-hop routing commands.</li>
</ol>
<pre><code>cmd_buf = B[:PER_HOP_RI_LENGTH]
new_routing_information = B[PER_HOP_RI_LENGTH:]

next_mix_command_idx = -1
routing_commands = [ ]
for idx = 0; idx &lt; PER_HOP_RI_LENGTH {
     /* WARNING: Bounds checking omitted for brevity. */
     cmd_type = b[idx]
     cmd = NULL
     switch cmd_type {
        case null: goto done  /* No further commands. */

        case next_node_hop:
            cmd = RoutingCommand( B[idx:idx+1+LEN( NextNodeHopCommand )] )
            next_mix_command_idx = i /* Save for step 7. */
            idx += 1 + LEN( NextNodeHopCommand )
            break

        case recipient:
            cmd = RoutingCommand( B[idx:idx+1+LEN( FinalDestinationCommand )] )
            idx += 1 + LEN( RecipientCommand )
            break

        case surb_reply:
            cmd = RoutingCommand( B[idx:idx+1+LEN( SURBReplyCommand )] )
            idx += 1 + LEN( SURBReplyCommand )
            break

      default:
            /* MUST abort processing on unrecognized commands. */
            return ErrorInvalidCommand
    }
    routing_commands += cmd /* Append cmd to the tail of the list. */
}
done:</code></pre>
<p>At the conclusion of the parsing step:</p>
<ul>
<li><code>routing_commands</code> - A vector of SphinxRoutingCommand, to
be applied at this hop.</li>
<li><code>new_routing_information</code> - The routing_information block
to be sent to the next hop if any.</li>
</ul>
<ol start="6" type="1">
<li>Decrypt the Sphinx Packet Payload.</li>
</ol>
<pre><code>payload = sphinx_packet.payload
payload = SPRP_Decrypt( key.payload_encryption, payload )
sphinx_packet.payload = payload</code></pre>
<ol start="7" type="1">
<li>Transform the packet for forwarding to the next mix, if the routing
commands vector included a NextNodeHopCommand.</li>
</ol>
<pre><code>if next_mix_command_idx != -1:
    cmd = routing_commands[next_mix_command_idx]
    hdr.group_element = EXP( hdr.group_element, keys.blinding_factor )
    hdr.routing_information = new_routing_information
    hdr.mac = cmd.MAC
    sphinx_packet.hdr = hdr</code></pre>
<h3 id="post-sphinx_unwrap-processing">6.2 Post Sphinx_Unwrap
Processing</h3>
<p>Upon the completion of the <code>Sphinx_Unwrap</code> operation,
implementations MUST take several additional steps. As the exact
behavior is mostly implementation specific, pseudocode will not be
provided for most of the post processing steps.</p>
<ol type="1">
<li>Apply replay detection to the packet.</li>
</ol>
<p>The <code>replay_tag</code> value returned by Sphinx_Unwrap MUST be
unique across all packets processed with a given
<code>private_routing_key</code>.</p>
<p>The exact specifics of how to detect replays is left up to the
implementation, however any replays that are detected MUST be discarded
immediately.</p>
<ol start="2" type="1">
<li>Act on the routing commands, if any.</li>
</ol>
<p>The exact specifics of how implementations chose to apply routing
commands is deliberately left unspecified, however in general:</p>
<ul>
<li><p>If there is a <code>NextNodeHopCommand</code>, the packet should
be forwarded to the next node based on the <code>next_hop</code> field
upon completion of the post processing.</p>
<p>The lack of a NextNodeHopCommand indicates that the packet is
destined for the current node.</p></li>
<li><p>If there is a <code>SURBReplyCommand</code>, the packet should be
treated as a SURBReply destined for the current node, and decrypted
accordingly (See <code>Section 7.2</code>)</p></li>
<li><p>If the implementation supports multiple recipients on a single
node, the <code>RecipientCommand</code> command should be used to
determine the correct recipient for the packet, and the payload
delivered as appropriate.</p>
<p>It is possible for both a RecipientCommand and a NextNodeHopCommand
to be present simultaneously in the routing commands for a given hop.
The behavior when this situation occurs is implementation
defined.</p></li>
</ul>
<ol start="3" type="1">
<li>Authenticate the packet if required.</li>
</ol>
<p>If the packet is destined for the current node, the integrity of the
payload MUST be authenticated.</p>
<p>The authentication is done as follows:</p>
<pre><code>derived_tag = sphinx_packet.payload[:PAYLOAD_TAG_LENGTH]
expected_tag = ZEROBYTES( PAYLOAD_TAG_LENGTH )
if !CONSTANT_TIME_CMP( derived_tag, expected_tag ):
    /* Discard the packet with no further processing. */
    return ErrorInvalidPayload</code></pre>
<p>Remove the authentication tag before presenting the payload to the
application.</p>
<pre><code>sphinx_packet.payload = sphinx_packet.payload[PAYLOAD_TAG_LENGTH:]</code></pre>
<h2 id="single-use-reply-block-surb-creation">7. Single Use Reply Block
(SURB) Creation</h2>
<p>A Single Use Reply Block (SURB) is a delivery token with a short
lifetime, that can be used by the recipient to reply to the initial
sender.</p>
<p>SURBs allow for anonymous replies, when the recipient does not know
the sender of the message. Usage of SURBs guarantees anonymity
properties but also makes the reply messages indistinguishable from
forward messages both to external adversaries as well as the mix
nodes.</p>
<p>When a SURB is created, a matching reply block Decryption Token is
created, which is used to decrypt the reply message that is produced and
delivered via the SURB.</p>
<p>The Sphinx SURB wire encoding is implementation defined, but for the
purposes of illustrating creation and use, the following will be
used:</p>
<pre><code>struct {
    SphinxHeader sphinx_header;
    opaque first_hop[NODE_ID_LENGTH];
    opaque payload_key[SPRP_KEY_LENGTH];
} SphinxSURB;</code></pre>
<h3 id="create-a-sphinx-surb-and-decryption-token">7.1 Create a Sphinx
SURB and Decryption Token</h3>
<p>Structurally a SURB consists of three parts, a pre-generated Sphinx
Packet Header, a node identifier for the first hop to use when using the
SURB to reply, and cryptographic keying material by which to encrypt the
reply’s payload. All elements must be securely transmitted to the
recipient, perhaps as part of a forward Sphinx Packet's Payload, but the
exact specifics on how to accomplish this is left up to the
implementation.</p>
<p>When creating a SURB, the terminal routing_commands vector SHOULD
include a SURBReplyCommand, containing an identifier to ensure that the
payload can be decrypted with the correct set of keys (Decryption
Token). The routing command is left optional, as it is conceivable that
implementations may chose to use trial decryption, and or limit the
number of outstanding SURBs to solve this problem.</p>
<pre><code>Sphinx_Create_SURB( additional_data, first_hop, path[] ) -&gt;
                                                 sphinx_surb,
                                                 decryption_token</code></pre>
<p>Inputs:</p>
<ul>
<li><code>additional_data</code> The Additional Data that is visible to
every node along the path in the header.</li>
<li><code>first_hop</code> The node id of the first hop the recipient
must use when replying via the SURB.</li>
<li><code>path</code> The vector of PathHop structures in hop order,
specifying the node id, public key, and routing commands for each
hop.</li>
</ul>
<p>Outputs:</p>
<ul>
<li><code>sphinx_surb</code> The resulting Sphinx SURB.</li>
<li><code>decryption_token</code> The Decryption Token associated with
the SURB.</li>
</ul>
<p>The Sphinx_Create_SURB operation consists of the following steps:</p>
<ol type="1">
<li>Create the Sphinx Packet Header and SPRP key vector.</li>
</ol>
<pre><code>sphinx_header, payload_keys =
      Sphinx_Create_Header( additional_data, path )</code></pre>
<ol start="2" type="1">
<li>Create a key for the final layer of encryption.</li>
</ol>
<pre><code>final_key = RNG( SPRP_KEY_LENGTH )</code></pre>
<ol start="3" type="1">
<li>Build the SURB and Decryption Token.</li>
</ol>
<pre><code>SphinxSURB sphinx_surb;
sphinx_surb.sphinx_header = sphinx_header
sphinx_surb.first_hop = first_hop
sphinx_surb.payload_key = final_key

decryption_token = final_key + payload_keys /* Prepend */</code></pre>
<h3 id="decrypt-a-sphinx-reply-originating-from-a-surb">7.2 Decrypt a
Sphinx Reply Originating from a SURB</h3>
<p>A Sphinx Reply packet that was generated using a SURB is externally
indistinguishable from a forward Sphinx Packet as it traverses the
network. However, the recipient of the reply has an additional
decryption step, the packet starts off unencrypted, and accumulates
layers of Sphinx Packet Payload decryption as it traverses the
network.</p>
<p>Determining which decryption token to use when decrypting the SURB
reply can be done via the SURBReplyCommand’s id field, if one is
included at the time of the SURB’s creation.</p>
<pre><code>Sphinx_Decrypt_SURB_Reply( decryption_token, payload ) -&gt; message</code></pre>
<p>Inputs:</p>
<ul>
<li><code>decryption_token</code> The vector of keys allowing a client
to decrypt the reply ciphertext payload. This decryption_token is
generated when the SURB is created.</li>
<li><code>payload</code> The Sphinx Packet ciphertext payload.</li>
</ul>
<p>Outputs:</p>
<ul>
<li><code>error</code> Indicating a unsuccessful unwrap operation if
applicable.</li>
<li><code>message</code> The plaintext message.</li>
</ul>
<p>The Sphinx_Decrypt_SURB_Reply operation consists of the following
steps:</p>
<ol type="1">
<li>Encrypt the message to reverse the decrypt operations the payload
acquired as it traversed the network.</li>
</ol>
<pre><code>for i = LEN( decryption_token ) - 1; i &gt; 0; --i:
    payload = SPRP_Encrypt( decryption_token[i], payload )</code></pre>
<ol start="2" type="1">
<li>Decrypt and authenticate the message ciphertext.</li>
</ol>
<pre><code>message = SPRP_Decrypt( decryption_token[0], payload )

derived_tag = message[:PAYLOAD_TAG_LENGTH]
expected_tag = ZEROBYTES( PAYLOAD_TAG_LENGTH )
if !CONSTANT_TIME_CMP( derived_tag, expected_tag ):
    return ErrorInvalidPayload

message = message[PAYLOAD_TAG_LENGTH:]</code></pre>
<h2 id="single-use-reply-block-replies">8. Single Use Reply Block
Replies</h2>
<p>The process for using a SURB to reply anonymously is slightly
different from the standard packet creation process, as the Sphinx
Packet Header is already generated (as part of the SURB), and there is
an additional layer of Sphinx Packet Payload encryption that must be
performed.</p>
<pre><code>Sphinx_Create_SURB_Reply( sphinx_surb, payload ) -&gt; sphinx_packet</code></pre>
<p>Inputs:</p>
<ul>
<li><code>sphinx_surb</code> The SphinxSURB structure, decoded from the
implementation defined wire encoding.</li>
<li><code>payload</code> The packet payload message plaintext.</li>
</ul>
<p>The Sphinx_Create_SURB_Reply operation consists of the following
steps:</p>
<ol type="1">
<li>Prepend the authentication tag, and append padding to the
payload.</li>
</ol>
<pre><code>payload = ZERO_BYTES( PAYLOAD_TAG_LENGTH ) | payload
payload = payload | ZERO_BYTES( PAYLOAD_LENGTH - LEN( payload ) )</code></pre>
<ol start="2" type="1">
<li>Encrypt the payload.</li>
</ol>
<pre><code>payload = SPRP_Encrypt( sphinx_surb.payload_key, payload )</code></pre>
<ol start="3" type="1">
<li>Assemble the completed Sphinx Packet.</li>
</ol>
<pre><code>SphinxPacket sphinx_packet
sphinx_packet.header = sphinx_surb.sphinx_header
sphinx_packet.payload = payload</code></pre>
<p>The completed <code>sphinx_packet</code> MUST be sent to the node
specified via <code>sphinx_surb.node_id</code>, as the entire reply
<code>sphinx_packet</code>’s header is pre-generated.</p>
<h2 id="anonymity-considerations">9. Anonymity Considerations</h2>
<h3 id="optional-non-constant-length-sphinx-packet-header-padding">9.1
Optional Non-constant Length Sphinx Packet Header Padding</h3>
<p>Depending on the mix topology, there is no hard requirement that the
per-hop routing info is padded to one fixed constant length.</p>
<p>For example, assuming a layered topology (referred to as stratified
topology in the literature) <a href="#MIXTOPO10">MIXTOPO10</a>, where
the layer of any given mix node is public information, as long as the
following two invariants are maintained, there is no additional
information available to an adversary:</p>
<ol type="1">
<li>All packets entering any given mix node in a certain layer are
uniform in length.</li>
<li>All packets leaving any given mix node in a certain layer are
uniform in length.</li>
</ol>
<p>The only information available to an external or internal observer is
the layer of any given mix node (via the packet length), which is
information they are assumed to have by default in such a design.</p>
<h3 id="additional-data-field-considerations">9.2 Additional Data Field
Considerations</h3>
<p>The Sphinx Packet Construct is crafted such that any given packet is
bitwise unlinkable after a Sphinx_Unwrap operation, provided that the
optional Additional Data (AD) facility is not used. This property
ensures that external passive adversaries are unable to track a packet
based on content as it traverses the network. As the on-the-wire AD
field is static through the lifetime of a packet (ie: left unaltered by
the <code>Sphinx_Unwrap</code> operation), implementations and
applications that wish to use this facility MUST NOT transmit AD that
can be used to distinctly identify individual packets.</p>
<h3 id="forward-secrecy-considerations">9.3 Forward Secrecy
Considerations</h3>
<p>Each node acting as a mix MUST regenerate their asymmetric key pair
relatively frequently. Upon key rotation the old private key MUST be
securely destroyed. As each layer of a Sphinx Packet is encrypted via
key material derived from the output of an ephemeral/static
Diffie-Hellman key exchange, without the rotation, the construct does
not provide Perfect Forward Secrecy. Implementations SHOULD implement
defense-in-depth mitigations, for example by using strongly
forward-secure link protocols to convey Sphinx Packets between
nodes.</p>
<p>This frequent mix routing key rotation can limit SURB usage by
directly reducing the lifetime of SURBs. In order to have a strong
Forward Secrecy property while maintaining a higher SURB lifetime,
designs such as forward secure mixes <a href="#SFMIX03">SFMIX03</a>
could be used.</p>
<h3 id="compulsion-threat-considerations">9.4 Compulsion Threat
Considerations</h3>
<p>Reply Blocks (SURBs), forward and reply Sphinx packets are all
vulnerable to the compulsion threat, if they are captured by an
adversary. The adversary can request iterative decryptions or keys from
a series of honest mixes in order to perform a deanonymizing trace of
the destination.</p>
<p>While a general solution to this class of attacks is beyond the scope
of this document, applications that seek to mitigate or resist
compulsion threats could implement the defenses proposed in <a
href="#COMPULS05">COMPULS05</a> via a series of routing command
extensions.</p>
<h3
id="surb-usage-considerations-for-volunteer-operated-mix-networks">9.5
SURB Usage Considerations for Volunteer Operated Mix Networks</h3>
<p>Given a hypothetical scenario where Alice and Bob both wish to keep
their location on the mix network hidden from the other, and Alice has
somehow received a SURB from Bob, Alice MUST not utilize the SURB
directly because in the volunteer operated mix network the first hop
specified by the SURB could be operated by Bob for the purpose of
deanonymizing Alice.</p>
<p>This problem could be solved via the incorporation of a “cross-over
point” such as that described in <a href="#MIXMINION">MIXMINION</a>, for
example by having Alice delegating the transmission of a SURB Reply to a
randomly selected crossover point in the mix network, so that if the
first hop in the SURB’s return path is a malicious mix, the only
information gained is the identity of the cross-over point.</p>
<h2 id="security-considerations">10. Security Considerations</h2>
<h3 id="sphinx-payload-encryption-considerations">10.1 Sphinx Payload
Encryption Considerations</h3>
<p>The payload encryption’s use of a fragile (non-malleable) SPRP is
deliberate and implementations SHOULD NOT substitute it with a primitive
that does not provide such a property (such as a stream cipher based
PRF). In particular there is a class of correlation attacks (tagging
attacks) targeting anonymity systems that involve modification to the
ciphertext that are mitigated if alterations to the ciphertext result in
unpredictable corruption of the plaintext (avalanche effect).</p>
<p>Additionally, as the PAYLOAD_TAG_LENGTH based tag-then-encrypt
payload integrity authentication mechanism is predicated on the use of a
non-malleable SPRP, implementations that substitute a different
primitive MUST authenticate the payload using a different mechanism.</p>
<p>Alternatively, extending the MAC contained in the Sphinx Packet
Header to cover the Sphinx Packet Payload will both defend against
tagging attacks and authenticate payload integrity. However, such an
extension does not work with the SURB construct presented in this
specification, unless the SURB is only used to transmit payload that is
known to the creator of the SURB.</p>
<h2 id="appendix-a.-references">Appendix A. References</h2>
<h3 id="appendix-a.1-normative-references">Appendix A.1 Normative
References</h3>
<h3 id="appendix-a.2-informative-references">Appendix A.2 Informative
References</h3>
<h2 id="appendix-b.-citing-this-document">Appendix B. Citing This
Document</h2>
<h3 id="appendix-b.1-bibtex-entry">Appendix B.1 Bibtex Entry</h3>
<p>Note that the following bibtex entry is in the IEEEtran bibtex style
as described in a document called “How to Use the IEEEtran BIBTEX
Style”.</p>
<pre><code>@online{SphinxSpec,
title = {Sphinx Mix Network Cryptographic Packet Format Specification},
author = {Yawning Angel and George Danezis and Claudia Diaz and Ania Piotrowska and David Stainton},
url = {https://github.com/katzenpost/katzenpost/blob/master/docs/specs/sphinx.rst},
year = {2017}
}</code></pre>
<p><strong>COMPULS05</strong></p>
<p>Danezis, G., Clulow, J., “Compulsion Resistant Anonymous
Communications”, Proceedings of Information Hiding Workshop, June 2005,
https://www.freehaven.net/anonbib/cache/ih05-danezisclulow.pdf</p>
<p><strong>MIXMINION</strong></p>
<p>Danezis, G., Dingledine, R., Mathewson, N., “Mixminion: Design of a
Type III Anonymous Remailer Protocol”,
https://www.mixminion.net/minion-design.pdf</p>
<p><strong>MIXTOPO10</strong></p>
<p>Diaz, C., Murdoch, S., Troncoso, C., “Impact of Network Topology on
Anonymity and Overhead in Low-Latency Anonymity Networks”, PETS, July
2010,
https://www.esat.kuleuven.be/cosic/publications/article-1230.pdf</p>
<p><strong>RFC2119</strong></p>
<p>Bradner, S., “Key words for use in RFCs to Indicate Requirement
Levels”, BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997,
http://www.rfc-editor.org/info/rfc2119</p>
<p><strong>RFC5246</strong></p>
<p>Dierks, T. and E. Rescorla, “The Transport Layer Security (TLS)
Protocol Version 1.2”, RFC 5246, DOI 10.17487/RFC5246, August 2008,
http://www.rfc-editor.org/info/rfc5246</p>
<p><strong>SFMIX03</strong></p>
<p>Danezis, G., “Forward Secure Mixes”, Proceedings of 7th Nordic
Workshop on Secure IT Systems, 2002,
https://www.freehaven.net/anonbib/cache/Dan:SFMix03.pdf</p>
<p><strong>SPHINX09</strong></p>
<p>Danezis, G., Goldberg, I., “Sphinx: A Compact and Provably Secure Mix
Format”, DOI 10.1109/SP.2009.15, May 2009,
https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf</p>
