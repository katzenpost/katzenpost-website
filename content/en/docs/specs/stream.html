---
title: 
linkTitle: "ScatterStream" 
description: "" 
url: "docs/specs/scatterstream.html" 
date: "2025-01-03T12:30:56.447213507-08:00"
draft: false 
slug: "" 
layout: "" 
type: "" 
weight: 1 
---
<!DOCTYPE HTML>
<html xmlns:ng="http://docbook.org/docbook-ng">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
      <title>ScatterStream</title>
      <meta name="generator" content="DocBook XSL Stylesheets V1.79.2">
      <meta name="description" content="The stream package provides an implementation of an asynchronous, reliable, and encrypted communication protocol on top of the Katzenpost network using a storage service abstraction.">
   </head>
   <body>
      <div class="article">
         <div class="titlepage">
            <div>
               <div>
                  <h1 class="title"><a name="scatterstream"></a>ScatterStream</h1>
               </div>
               <div>
                  <div class="authorgroup">
                     <div class="author">
                        <h3 class="author"><span class="firstname"></span> <span class="surname">Masala</span></h3>
                     </div>
                  </div>
               </div>
               <div>
                  <div class="abstract">
                     <p class="title"><b>Abstract</b></p>
                     <p> The stream package provides an implementation of an asynchronous, reliable, and
                        encrypted communication protocol on top of the Katzenpost network using a storage
                        service abstraction. </p>
                  </div>
               </div>
            </div>
            <hr>
         </div>
         <div class="toc">
            <p><b>Table of Contents</b></p>
            <dl class="toc">
               <dt><span class="section"><a href="#overview">Overview</a></span></dt>
               <dt><span class="section"><a href="#protocol-description">Protocol description</a></span></dt>
               <dt><span class="section"><a href="#establishing-secrets">Establishing secrets</a></span></dt>
               <dt><span class="section"><a href="#frame-encryption">Frame Encryption</a></span></dt>
               <dt><span class="section"><a href="#key-derivation">Key Derivation</a></span></dt>
               <dt><span class="section"><a href="#data-frames">Data Frames</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="#types-of-frames">Types of Frames</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="#stream-state">Stream State</a></span></dt>
               <dt><span class="section"><a href="#stream-worker-routines">Stream worker routines</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="#receiving-frames">Receiving Frames</a></span></dt>
                     <dt><span class="section"><a href="#transmitting-frames">Transmitting Frames</a></span></dt>
                     <dt><span class="section"><a href="#re-transmission-of-unacknowledged-frames">Re-Transmission of
                              UnAcknowledged Frames</a></span></dt>
                     <dt><span class="section"><a href="#acknowledging-received-frames">Acknowledging Received
                              Frames</a></span></dt>
                  </dl>
               </dd>
               <dt><span class="section"><a href="#finite-state-machine">Finite State Machine</a></span></dt>
               <dd>
                  <dl>
                     <dt><span class="section"><a href="#transition-to-streamclosing-writer">Transition to StreamClosing
                              (writer):</a></span></dt>
                     <dt><span class="section"><a href="#transition-to-streamclosing-reader">Transition to StreamClosing
                              (reader):</a></span></dt>
                     <dt><span class="section"><a href="#transition-to-streamclosed-reader">Transition to StreamClosed
                              (reader):</a></span></dt>
                     <dt><span class="section"><a href="#transition-to-streamclosed-writer">Transition to StreamClosed
                              (writer):</a></span></dt>
                  </dl>
               </dd>
            </dl>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="overview"></a>Overview</h2>
                  </div>
               </div>
            </div>
            <p> Stream provides provided for establishing reliable bidirectional communication
               channel between a pair of clients using a shared secret, and a key-value scratchpad
               service for exchanging messages. From the shared secret, sequences of message storage
               addresses (32 bytes) and symmetric message encryption keys are derived. Each client
               runs
               protocol state machines that fetch, transmit and acknowledge frames of data, and
               re-transmit unacknowledged frames in order to provide a reliable delivery of data
               via a
               lossy storage service. Storage addresses are mapped to nodes published in Katzenpost&#x2019;s
               Directory Authority system, which runs a service called <span class="quote">&#x201c;<span class="quote">Map</span>&#x201d;</span> that provides
               a simple lossy storage service where content is limited to a configurable buffer size
               and automatically expire. </p>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="protocol-description"></a>Protocol description</h2>
                  </div>
               </div>
            </div>
            <p> Stream establishes an asynchronous bidirectional reliable communication channel
               between 2 parties: by convention, one is a Listener and the other the Dialer. The
               2
               parties must exchange a shared secret, which is used to derive secrets for encrypting
               and addressing Frames of a Stream. Each Frame is identified by a cryptographically
               secure random ID chosen from a deterministic CSPRNG so that each party knows the
               sequence of Frame ID&#x2019;s used to address messages to and from the other party. Similarly,
               a deterministic sequence of symmetric Frame encryption keys are used to encrypt each
               Frame. Frames are written to a storage service, so that each party may send or receive
               messages while the other party is offline, and Frames are acknowledged by transmitting
               the greatest sequential frame seen. Frames that are not acknowledged are periodically
               re-transmitted, so that reliable delivery is provided end-to-end by the clients and
               not
               the storage service. </p>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="establishing-secrets"></a>Establishing secrets</h2>
                  </div>
               </div>
            </div>
            <p> A cryptographically strong (32 byte) shared secret is used as initial keying material
               and expanded by HKDF (HMAC-based Key Derivation Function) to produce 4 secrets which
               are
               the seeds for a deterministic CSPRNG (SHA256 of the seed + an 8 byte counter) that
               produce the sequences of Frame ID&#x2019;s and encryption keys for each peer. This implies
               that
               each party knows the other party&#x2019;s keys and can impersonate the other party, which
               is
               not considered to be a problem for the 2 party design of Stream, however future work
               may
               establish secrets from a cryptographic handshake so that read-only capabilities can
               be
               exchanged so that multiple readers may read messages from a peer without being able
               to
               modify ciphertext on the storage service. </p>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="frame-encryption"></a>Frame Encryption</h2>
                  </div>
               </div>
            </div>
            <p> The txFrame method is responsible for encrypting and transmitting frames. It uses
               secretbox from the NaCl library for encryption. Encryption keys are derived from hashing
               the frame encryption key with the frame ID, and a 24 byte random nonce is prepended
               to
               the ciphertext. </p>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="key-derivation"></a>Key Derivation</h2>
                  </div>
               </div>
            </div>
            <p> Stream uses HKDF (HMAC-based Key Derivation Function) for deriving encryption keys
               and frame ID sequence seeds from the provided shared secret. </p>
            <p><span class="strong"><strong>WriteKey:</strong></span> This is a pointer to a [keySize]byte array,
               representing the encryption key used for encrypting data frames before transmitting
               them. It is used in the txFrame function to derive the encryption key for a specific
               frame during transmission. This key ensures the confidentiality and integrity of the
               transmitted data. </p>
            <p><span class="strong"><strong>ReadKey:</strong></span> Similar to WriteKey, ReadKey is a pointer to
               a [keySize]byte array, representing the decryption key used for decrypting incoming
               data
               frames. It is used in the readFrame function to derive the decryption key for a specific
               frame during reception. This key is crucial for decrypting and processing the received
               data. </p>
            <p><span class="strong"><strong>WriteIDBase:</strong></span> This is a common.MessageID (a 32-byte
               array) representing the base for deriving message IDs during frame transmission. It
               is
               used in the txFrameID function to generate a unique identifier for each transmitted
               frame. The message ID is combined with a frame-specific value to create a unique
               identifier for each frame. </p>
            <p><span class="strong"><strong>ReadIDBase:</strong></span> Similar to WriteIDBase, ReadIDBase is a
               common.MessageID representing the base for deriving message IDs during frame reception.
               It is used in the rxFrameID function to generate a unique identifier for each received
               frame. The message ID is combined with a frame-specific value to create a unique
               identifier for each frame. </p>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="data-frames"></a>Data Frames</h2>
                  </div>
               </div>
            </div>
            <p> The fundamental unit of communication is a <span class="quote">&#x201c;<span class="quote">Frame.</span>&#x201d;</span> Frames are
               CBOR-encoded go structs, and a Frame contains metadata and payload data. Metadata
               of a
               frame is the type of the frame (StreamStart, StreamData, or StreamEnd), and an
               acknowledgment sequence number (Ack). The Payload field in the Frame holds the actual
               data being transported. </p>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="types-of-frames"></a>Types of Frames</h3>
                     </div>
                  </div>
               </div>
               <p> There are 3 FrameTypes: StreamStart, StreamData, and StreamEnd. The first frame
                  in a Stream must be type StreamStart, following data frames are StreamData, and the
                  final frame must be a StreamEnd. </p>
            </div>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="stream-state"></a>Stream State</h2>
                  </div>
               </div>
            </div>
            <p> The Stream type manages the state of communication. It includes parameters such as
               PayloadSize, WindowSize, MaxWriteBufSize, and others. </p>
            <p><span class="strong"><strong>Addr:</strong></span> is the <span class="quote">&#x201c;<span class="quote">address</span>&#x201d;</span> of a Stream which
               is the shared secret used to establish the Stream. <span class="strong"><strong>Initiator:</strong></span> is true if the Stream state was established by the Listener
               party. <span class="strong"><strong>WriteKey:</strong></span> and ReadKey are used to derive frame
               encryption secrets <span class="strong"><strong>WriteIDBase:</strong></span> The secret derived
               from the shared secret used to derive each frame ID written. <span class="strong"><strong>ReadIDBase:</strong></span> The secret derived from the shared secret used to derive
               each frame ID read. <span class="strong"><strong>PayloadSize:</strong></span> is the frame payload
               length, and must not change after a Stream has been established. <span class="strong"><strong>ReadIdx:</strong></span> The counter corresponding to the current frame being requested,
               and used to derive the storage location address in combination with ReadIDBase.
               <span class="strong"><strong>WriteIdx:</strong></span> The counter corresponding to the next
               frame to be written and used to derive the storage location address in combination
               with
               WriteIDBase. <span class="strong"><strong>AckIdx:</strong></span> The counter that keeps track of
               the last acknowledgement sent to the peer. <span class="strong"><strong>PeerAckIdx:</strong></span> The counter tracking the last acknowledgement sent from the
               peer. <span class="strong"><strong>WindowSize:</strong></span> The number of frames ahead of the
               remote peer&#x2019;s PeerAckIDxthat will be transmitted. Peers which peers must agree on
               WindowSize as Stream does not presently support dynamically adjusting WindowSize.
               **MaxWriteBufSize is the buffered bytes that Stream will hold before blocking calls
               to
               Write. </p>
            <p> Stream has separate states for reading (RState) and writing (WState) that correspond
               to the reader and writer routines. Both finite state machines have 3 valid states:
               StreamOpen, StreamClosing, and StreamClosed. </p>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="stream-worker-routines"></a>Stream worker routines</h2>
                  </div>
               </div>
            </div>
            <p> Each Stream has two goroutines, a reader and writer routine, which are responsible
               for handling read and write operations, respectively. The reader continuously polls
               for
               incoming frames, processes acknowledgments, and updates the read buffer. When the
               ReadIdx exceeds the AckIdx + WindowSize it prodes the writer routine to send an
               Acknowledgement, even if there is no Payload data to send. The writer routine transmits
               frames of data from the write buffer when available, re-transmits unacknowledged frames,
               and Acknowledges received frames. The writer routine waits until there is more data
               to
               send or is signalled by the reader routine in order to send an Acknowledgement.
               Retransmissions are accomplished by the TimerQueue worker routine that waits until
               a
               timeout has occurred and re-sends an unacknowledged frame. </p>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="receiving-frames"></a>Receiving Frames</h3>
                     </div>
                  </div>
               </div>
               <p> The reader routine is responsible for reading frames from a stream. If a read
                  operation returns an error, it increases the interval that it waits before trying
                  to
                  read another frame. On successful reads, the fetch interval is decreased. When a
                  StreamEnd frame is encountered, the reader routine terminates. </p>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="transmitting-frames"></a>Transmitting Frames</h3>
                     </div>
                  </div>
               </div>
               <p> The writer routine is responsible for reading frames of data from the write
                  buffer, chunking data into frames, sending frames to the storage service and adding
                  frames to the re-transmission queue. When there is data available to send and
                  WriteIdx-PeerAckIdx &lt; WindowSize, the writer sends Frames of data. When the
                  WindowSize is reached, the writer routine sleeps until woken by the reader routine
                  to acknowledge data or woken by a call to Write. In the latter case, the writer may
                  buffer addtional data but must not transmit additional frames. </p>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="re-transmission-of-unacknowledged-frames"></a>Re-Transmission of
                           UnAcknowledged Frames</h3>
                     </div>
                  </div>
               </div>
               <p> When the writer routine sends a frame, a copy of the frame is placed into a
                  re-transmisison queue. Unacknowledged frames are periodically re-transmitted.
                  Contents of the re-transmission queue are preserved and restored by Save and
                  LoadStream. </p>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="acknowledging-received-frames"></a>Acknowledging Received
                           Frames</h3>
                     </div>
                  </div>
               </div>
               <p> When a sequential frame is successfully read the reader routine updates the
                  AckIdx to ReadIdx, and increments ReadIdx. If ReadIdx exceeds AckIdx by the
                  WindowSize, the reader must signal to the writer routine to transmit an
                  acknowledgement. </p>
            </div>
         </div>
         <div class="section">
            <div class="titlepage">
               <div>
                  <div>
                     <h2 class="title" style="clear: both"><a name="finite-state-machine"></a>Finite State Machine</h2>
                  </div>
               </div>
            </div>
            <p> A Stream consists of two finite state machines, which correspond to a reader and
               writer thread, each of which can be in state StreamOpen, StreamClosing, or StreamClosed.
               When a Stream is created, it starts in state StreamOpen. </p>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="transition-to-streamclosing-writer"></a>Transition to StreamClosing
                           (writer):</h3>
                     </div>
                  </div>
               </div>
               <p> The Close method is responsible for initiating the process of closing a stream.
                  When Close is called, it first checks whether the stream is in the StreamOpen state.
                  If so, it sets the WState to StreamClosing. After setting the state to
                  StreamClosing, it triggers the doFlush method to wake up the writer goroutine,
                  allowing it to transmit any pending frames, including a final frame indicating the
                  end of the stream. The StreamClosing state indicates that the stream is in the
                  process of closing, and no new data can be written to it. </p>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="transition-to-streamclosing-reader"></a>Transition to StreamClosing
                           (reader):</h3>
                     </div>
                  </div>
               </div>
               <p> The reader StreamClosing state is entered when the Close method is called. While
                  in the StreamClosing state, the reader routine continues fetching and processing
                  incoming frames. </p>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="transition-to-streamclosed-reader"></a>Transition to StreamClosed
                           (reader):</h3>
                     </div>
                  </div>
               </div>
               <p> If the reader routine encounters a final frame of type StreamEnd during the
                  StreamClosing state, it transitions to StreamClosed. </p>
            </div>
            <div class="section">
               <div class="titlepage">
                  <div>
                     <div>
                        <h3 class="title"><a name="transition-to-streamclosed-writer"></a>Transition to StreamClosed
                           (writer):</h3>
                     </div>
                  </div>
               </div>
               <p> The writer goroutine (writer method) continuously checks the state of the stream.
                  When it observes that the WState is set to StreamClosing, it proceeds to finalize
                  the stream. During the finalization, it sets the WState to StreamClosed and
                  transmits a final frame of type StreamEnd. After transmitting the final frame, it
                  signals the onStreamClose channel to unblock any blocked calls to Close. The
                  StreamClosed state indicates that the stream is closed, and no further data can be
                  written or read. </p>
            </div>
         </div>
      </div>
   </body>
</html>