[{"body":"Welcome to the Katzenpost Blog. Here you will find two categories: News and Releases.\n","categories":"","description":"","excerpt":"Welcome to the Katzenpost Blog. Here you will find two categories: …","ref":"/blog/","tags":"","title":"Blog"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/cryptography/","tags":"","title":"Cryptography"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/design/","tags":"","title":"Design"},{"body":"Here we present a draft of the Katzenpost mixnet threat model document. We regard the threat model document as a living document which is frequently edited and in need of ongoing maintenance as we continue to develop newer mixnet protocols. Currently it is being organized by mixnet attack category and we have arranged attacks in a table with corresponding attacker capabilities. Later sections of the document present a deep dive into the core cryptographic protocols that comprise Katzenpost, namely these three:\nKatzenpost Directory Authority PKI protocol PQ Noise based wire protocol (on top of TCP or QUIC) Sphinx nested encrypted packet routing protocol Those are the basics necessary for point to point communications through the mix network. However mixnet protocols will then add their own cryptographic protocols which simply make use of the above three protocols in service to their goals of message transportation.\nWe thank Wau Holland Stiftung for funding this work.\nThreat Model Doc\n","categories":"","description":"","excerpt":"Here we present a draft of the Katzenpost mixnet threat model …","ref":"/blog/2024-04-25-threat-model/","tags":["research","design","threat model","security","privacy","cryptography"],"title":"Katzenpost threat model document"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/privacy/","tags":"","title":"Privacy"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/research/","tags":"","title":"Research"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/security/","tags":"","title":"Security"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/threat-model/","tags":"","title":"Threat Model"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/mathematics/","tags":"","title":"Mathematics"},{"body":"We are presenting our overview of existing Mixnet literature. It takes some liberties with what is included or not. It proposes new ways to talk about some issues, and provides a critical analysis of some of the existing papers. It also endeavors to introduce the reader to the language of anonymity systems, while maintaining mathematical rigor.\nThis doc, in particular, does not talk about the Katzenpost design. It does introduce the reader to some of the reasons why we’ve been making certain design decisions, and a keen eye might be led to some of the similar conclusions. But here we focus on already published research. We also stick to theory and don’t focus on any practical systems being built today.\nThe specific networking decisions implemented in Katzenpost so far, and the threats they mitigate and don’t, will be addressed in an upcoming, detailed threat model document.\nWe thank Wau Holland Stiftung for funding this work.\nLit Review Doc\nNote form Eva: I understand that the tone of some of this analysis may come across as harsh. I personally take full responsibility for this tone and critique in particular.\nAt the same time, the point of this doc is not to present original research. Some exploitable mistakes in existing research were withheld from this version, and original contributions are included if I, personally, feel like they are merely reinventing the wheel in bridging some of the gaps between Mixnets and Mathematics. Some of the other original research is mentioned, but will be expanded on elsewhere.\n","categories":"","description":"Foundational work ","excerpt":"Foundational work ","ref":"/blog/2024-04-15-lit-review/","tags":["research","cryptography","design","outreach","mathematics"],"title":"Mixnet Literature Overview"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/outreach/","tags":"","title":"Outreach"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/hpqc/","tags":"","title":"Hpqc"},{"body":"The Katzenpost developement team has recently released a new golang cryptography library known as hpqc. The theme of the library is hybrid post quantum cryptographic constructions, namely:\nhybrid KEMs (key encapsulation mechanism) hybrid NIKEs (non-interactive key exchange) hybrid signature schemes In each of the three main subdirectories, “kem”, “nike” and “sign” there exists interface definitions for Scheme, PrivateKey and PublicKey. For signature schemes and KEMs we’re borrowing the interface sets from cloudflare’s circl library.\nAnd each of these subdirectories has a schemes package where all the imeplementations are registered and can be referenced by unique string name, take for examples the KEM schemes documentation. However the implementations that are registered don’t show up in the API docs but we can see them in the source code.\nhpqc gives you the power to compose an arbitrary number of KEMs and NIKEs, for example the above source file defines many KEMs in composition like this one:\ncombiner.New( \"X25519-mlkem768-ctidh512\", []kem.Scheme{ adapter.FromNIKE(x25519.Scheme(rand.Reader)), mlkem768.Scheme(), adapter.FromNIKE(ctidh512.Scheme()), }, ), This library makes seven unique contributions in golang:\na set of generic NIKE interfaces for NIKE scheme, public key and private key types NIKE interfaces documentation source code\nThese are useful for making your cryptographic protocol not rely on a specific NIKE such as an elliptic curve diffiehellman function like x25519 or x448.\ngeneric hybrid NIKE, combines any two NIKEs into one NIKE hybrid scheme documentation source code\nMany cryptographic protocols can use a hybrid post quantum NIKE in place of a NIKE. Here the NIKE interfaces are satisfied by this hybrid scheme type.\nsecurity preserving KEM combiner security preserving KEM combiner documentation source code\nOur security preserving KEM combiner can combine an arbitrary number of KEMs althought it’s usually useful enough to combine just two KEMs. We get our design from the KEM Combiners paper which makes the observation that if a KEM combiner is not security preserving then the resulting hybrid KEM will not have IND-CCA2 security if one of the composing KEMs does not have IND-CCA2 security. Likewise the paper points out that when using a security preserving KEM combiner, if only one of the composing KEMs has IND-CCA2 security then the resulting hybrid KEM will have IND-CCA2 security.\nOur KEM combiner uses the split PRF design for an arbitrary number of KEMs, here shown with only three, in pseudo code:\nfunc SplitPRF(ss1, ss2, ss3, cct1, cct2, cct3 []byte) []byte { cct := cct1 || cct2 || cct3 return PRF(ss1 || cct) XOR PRF(ss2 || cct) XOR PRF(ss3 || cct) } a “NIKE to KEM adapter” which uses an ad hoc hashed elgamal construction NIKE to KEM adapter documentation source code\nIt is very common in modern hybrid post quantum cryptographic protocol constructions to see a NIKE adapted into a KEM and then combined with a post quantum KEM.\nOur ad hoc hashed elgamal construction for adapting any NIKE to a KEM is, in pseudo code:\nfunc ENCAPSULATE(their_pubkey publickey) ([]byte, []byte) { my_privkey, my_pubkey = GEN_KEYPAIR(RNG) ss = DH(my_privkey, their_pubkey) ss2 = PRF(ss || their_pubkey || my_pubkey) return my_pubkey, ss2 } func DECAPSULATE(my_privkey, their_pubkey) []byte { s = DH(my_privkey, their_pubkey) shared_key = PRF(ss || my_pubkey || their_pubkey) return shared_key } cgo bindings for the Sphincs+ C reference source Our Sphincs+ wrapper conforms to the signature scheme interfaces:\nSphincs+ signature scheme documentation source code\nWe maintain our Sphincs+ C reference fork and golang bindings in this git repo: https://github.com/katzenpost/sphincsplus/\nHere’s the cgo bindings source code: https://github.com/katzenpost/sphincsplus/blob/main/ref/binding.go\ncgo bindings for the CTIDH C source Our CTIDH golang bindings have been much improved through collaboration and are now maintained by the Vula project in this git repo:\nhttps://codeberg.org/vula/highctidh\nhpqc currently has a wrapper type for each CTIDH key size, as documented here:\nhttps://pkg.go.dev/github.com/katzenpost/hpqc@v0.0.17/nike/ctidh/ctidh511 https://pkg.go.dev/github.com/katzenpost/hpqc@v0.0.17/nike/ctidh/ctidh512 https://pkg.go.dev/github.com/katzenpost/hpqc@v0.0.17/nike/ctidh/ctidh1024 https://pkg.go.dev/github.com/katzenpost/hpqc@v0.0.17/nike/ctidh/ctidh2048\ngeneric hybrid signature scheme, combines any two signature schemes into one It is useful to combine a classical signature scheme such as ed25519 with a post quantum signature scheme such as Sphincs+.\nhybrid signature scheme documentation source code\n","categories":"","description":"","excerpt":"The Katzenpost developement team has recently released a new golang …","ref":"/blog/2024-04-12-hpqc/","tags":["hpqc","cryptography"],"title":"hpqc - hybrid post quantum cryptography library"},{"body":"Dr. Eva Infeld and surveillance expert and developer Leif Ryge held a session at the Chaos Communication Congress about the current state of the project, some of the things we’re working on, and some of the pitfalls many anonymity systems fall into. Building an anonymity system fit for our dystopian age is a hard problem, but we’re doing it.\n","categories":"","description":"The session we held at Chaos Communication Congress","excerpt":"The session we held at Chaos Communication Congress","ref":"/blog/2024-01-28-katzenpost-at-37c3/","tags":["research","talk","cryptography","design","outreach","mathematics"],"title":"Katzenpost at 37C3"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/talk/","tags":"","title":"Talk"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/apps/","tags":"","title":"Apps"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/audio/","tags":"","title":"Audio"},{"body":"Modern Mixnets have a unique set of requirements when it comes to processing audio. The bandwidth is scarce, but we expect to use modern devices and have ample processing power. We aim to secure the communication against even sophisticated attacks that come from capturing the metadata, and prioritize tools that are free, open source and written with security in mind. In this unique setting, we present a set of recommendations for implementing codecs, DSPs, and sophisticated noise reduction tools, to deliver either impressive quality at low bandwidth or good quality at impressively low bandwidth.\nRead Research Paper\nAudio Engineering Considerations for a Modern Mixnet\nPDF / 295K ","categories":"","description":"Original research into audio engineering considerations for apps on low latency mixnetworks","excerpt":"Original research into audio engineering considerations for apps on …","ref":"/blog/2023-11-25-audio-engineering-considerations/","tags":["research","audio","apps"],"title":"Audio Engineering Considerations for a Modern Mixnet"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/hugo/","tags":"","title":"Hugo"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/launches/","tags":"","title":"Launches"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/website/","tags":"","title":"Website"},{"body":"To match all the code development in Katzenpost in the last year, it was time for a website relaunch. Our site was a migration from Sphinx, which is primarily for documentation, to Hugo which is wildly configurable for all sorts of websites. Given the technical nature and need for nice documentation interface, we used the well crafted and maintained Docsy theme.\nWebsite Dependencies\nHugo static site generator Docsy theme for Hugo Bootstrap 5 is bundled in Docsy Decap CMS for a user-friendly GUI ","categories":"","description":"\u003e To match all the code development in Katzenpost in the last year, it was time for a website relaunch. Our site was a migration from Sphincs to Hugo and utilizes the well crafted and maintained Docsy theme.","excerpt":"\u003e To match all the code development in Katzenpost in the last year, it …","ref":"/blog/2023-11-24-website-relaunch/","tags":["website","launches","hugo"],"title":"Website Relaunch and migration to Hugo"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/blog/","tags":"","title":"Blog"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/katzenpost/","tags":"","title":"Katzenpost"},{"body":"Greetings,\nThe last few weeks have been very busy. I now have the basic working prototype implementation of a new Katzenpost messaging system. This new system has mutual location hiding properties for communication partners because recipients retreive their messages from a remote spool using a Sphinx SURB based protocol. SPHINX SPHINXSPEC\nNaming things is tricky. I had to call it something:\nhttps://github.com/katzenpost/katzenpost/tree/main/catshadow This messaging system is inspired by agl’s pond, obviously. See agl’s pond.\nI forked agl’s Double Ratchet from pond:\ndoubleratchet Also forked agl’s PANDA:\npanda Communication partners use a remote spool service which is now, memspool but later it will be a replicating CRDT:\nmemspool In order to exchange double ratchet keys and spool identities to form a bidirectional cryptographic channel, clients make use of the PANDA service. That is to say, PANDA (Phrase Automated Nym Discovery Authentication) is just another mixnet service like the memspool service mentioned above.\nThe user interface I wrote is a CLI terminal interface and it really kind of sucks. I’m feeling rather inspired by Special’s golang Ricochet. The UI and the backend are two separate processes and communicate by unix domain socket. Cool. Maybe I should do a similar construction that way someone else can later write a crazy C++ Gtk UI for this thing. Although I suspect this strategy doesn’t work well with Android. Unclear. At any rate, catshadow is crash fault tolerant, I hope. It is also internally way more simple than mailproxy and doesn’t use database transactions or anything like that. State is persisted to disk in an encrypted statefile… passphrase, argon2, nacl secretbox of course.\nAnyway describing this whole thing is basically a paper worth of words which I shall attempt to articulate later. The overall strategy for Katzenpost should be for this client to merely serve as a demonstration. Whereas it would be far better to help another software project integrate with Katzenpost. Projects such as Briar and Wire come to mind. That having been said, I’d like to soon start a volunteer operated Katzenpost mix network so that we have some real infrastructure that allows us to start using catshadow to send each other encrypted messages. The amount of metadata we leak onto the network will depend on how many people use the system, number of mixes and of course how it is tuned. Since tuning is currently an unsolved problem, it’s all just a fun game anyway.\nOK folks that’s all for now. I am not sure exactly what the next steps should be and I’m planning on deliberating while I discuss it with my colleagues and advisors. Either I will start a demo mixnet all on one machine that we can use to try out catshadow or I will attempt to instigate a volunteer operated mixnet. Things will get very cool once we have multiple applications that can use the mixnet. :)\nCheers,\nDavid\n","categories":"","description":"","excerpt":"Greetings,\nThe last few weeks have been very busy. I now have the …","ref":"/blog/2019-05-04/","tags":["katzenpost","blog"],"title":"Monthly News Update (May 2019)"},{"body":"Greetings,\nThe Panoramix grant project funded by the European Commission has officially ended but the Katzenpost free software project lives on. Masala and I continue to work on Katzenpost for grant money given to us by Samsung.\nWe recently learned a few things about mixnet design in a series of design meetings. The conclusions from our learnings is too much information and detail for this here post. However I will summarize some of our conclusions below. Our discussions usually revolved around mixnet CRDT applications, client reliability, message spool server design, client decoy traffic and, preventing attacks: statistical disclosure and active confirmation attacks.\nAlthough far from complete, we added some design considerations to the following draft specification documents:\nhttps://github.com/katzenpost/docs/blob/master/drafts/client.rst https://github.com/katzenpost/docs/blob/master/drafts/deaddrop.rst https://github.com/katzenpost/docs/blob/master/drafts/decoy_traffic.rst\nThe new Katzenpost mixnet design will work as follows:\nClients will NOT send each other messages directly to each other’s Provider. A client’s Provider and spool ID is kept secret while clients share remote spool identities and remote spool Providers with each other instead. This allows a threat model of mutual distrust between clients. This design can help prevent clients from leaking more metadata such as geographical location.\nMessages are encrypted as follows: Firstly, the higher layer communications channel mechanism will use a modern cryptographic ratchet for forward secrecy and post compromise security properties. However, this ciphertext will be encapsulated by the Noise X oneway handshake. The nonce used by Noise X ensures that even if the client transmits the ratchet ciphertext, the Noise X ciphertext will always look different. This accomplishes our goal of not leaking retransmissions to spool Providers.\nSpool servers are now kept outside of the Katzenpost mix server source repository. That is to say, we make use of a plugin system for our mix server so that Providers can add arbitrary services to the mix network. We intend to use an iterative approach to designing and implementing remote message spools. The basic messaging use case as described above can be improved in the future by implementing the message spools as CRDT’s. This will allow spools to be replicated and this eliminates single points of failure in the network. In contrast the original Loopix design, each client has a single message spool on their Provider. If this Provider has an outage then that client will be unable to access their message spool.\nClients and mixnet plugin services will together optionally make use of a publish subscribe protocol.\nClients will send normal and decoy traffic in accordance with the timing provided by the original Loopix tuning parameters: λP, λL, λD, λM.\nOur mission is to enable other communications software projects to use mix networks to reduce their metadata leakage. To that end we have been working on mixnet client libraries that can be used by anyone. Although in the future we are planning to write a generic client daemon which you can interact with using a Unix domain socket. We hope that this will be an effective combination for enabling other projects to use a Katzenpost mix network.\nAlthough we are still in an unstable and rapid development phase we made some recent improvements to the Katzenpost mix server:\nMade it support running in networked environments with NAT devices.\nAdded a new plugin system which is hopefully less annoying to use than our existing gRPC based plugin system. The new plugin system uses CBOR over HTTP over Unix domain sockets. Katzenpost mix server plugins allow you to add arbitrary query/response services to your mix network. That is, you send a SURB and a query payload to a service and it can send one reponse using that SURB.\nI’ve provided some “echo” service plugins as examples of how to write plugins for Katzenpost in our server_plugins repo:\nhttps://github.com/katzenpost/server_plugins\nHOWEVER, we have for over a year supported BTC and Zcash cryptocurrency submitions via the “currency” plugin, here:\nhttps://github.com/katzenpost/server_plugins/tree/master/grpc_plugins/currency\nOther areas of improvement include fixing some bugs in the Voting Authority server and changing our PKI document to include all the Loopix tuning parameters: λP, λL, λD, λM. Thanks to Masala and Moritz we made recent progress in implementing a continuous integration system that runs kimchi based integration tests.\nYes, Katzenpost is a general purpose transport for message oriented applications. All client applications using the mix network look the same. My “elite dark mixnet wallet” for Zcash will have a traffic profile of λP, λL, λD just like mixnet chat client. Just as soon as we stabilize our client library we will actively seek collaborations with application developers.\nI’ve made a few screencasts to explain about mix networks and Katzenpost:\nKatzenpost Introduction draft https://www.youtube.com/watch?v=vDJihqksd6w\nA Brief Introduction to mix networks https://www.youtube.com/watch?v=1VMUb47QhfE\nMix Network Topology https://www.youtube.com/watch?v=bxk4H_X_OsM\nIntroduction to Statistical Disclosure Attacks and Defenses for Mix Networks https://www.youtube.com/watch?v=pHLbe1JKrAQ\nCheers,\nDavid Stainton\n","categories":"","description":"","excerpt":"Greetings,\nThe Panoramix grant project funded by the European …","ref":"/blog/2019-04-10/","tags":["katzenpost","blog"],"title":"Monthly News Update (April 2019)"},{"body":"Hi,\nI wrote some notes about making mixnet components in Rust that are binary compatible with existing Katzenpost components\nRustification The goal should be binary compatibility with the golang implementation of Katzenpost such that the existing golang components can interoperate with the new Rust components. Perhaps the biggest advantage of using Rust would be for writing mixnet clients as opposed to mix servers. A Rust mixnet client could easily present a FFI that could be used by user interfaces written in Java for Android and Swift for iOS.\nI wrote several relavant rust crates:\nhttps://crates.io/crates/aez https://crates.io/crates/ecdh_wrapper https://crates.io/crates/mix_link https://crates.io/crates/rust-lioness https://crates.io/crates/epoch https://crates.io/crates/sphinx_replay_cache https://crates.io/crates/sphinxcrypto Sphinx binary compatibility https://crates.io/crates/sphinxcrypto The rust Sphinx uses the exact same cryptographic primitives as the golang implementation. Therefore it should be fairly easy to make them binary compatible. They should share test vectors.\nMix link layer binary compatibility https://crates.io/crates/mix_link Currently this mix link layer crate uses Noise_XX_25519_ChaChaPoly_BLAKE2b however if the Katzenpost link layer were to upgrade to Kyber then the task of making this crate binary compatibility would be greatly simplified.\nHere’s an implementation of Kyber:\nhttps://crates.io/crates/kyber This mix_link crate uses the snow Noise protocol library implementation:\nhttps://crates.io/crates/snow However we SHOULD patch snow with Kyber PQ KEM hybrid forward secrecy. Here’s the snow github ticket for this task:\nhttps://github.com/mcginty/snow/issues/39 Mix server Current work in progress rust mix server:\nhttps://github.com/david415/mix_server Development progress has halted due to not being able to interoperate with the existing Katzenpost Directory Authority system.\n","categories":"","description":"","excerpt":"Hi,\nI wrote some notes about making mixnet components in Rust that are …","ref":"/blog/2019-01-19/","tags":["katzenpost","blog"],"title":"Rustification"},{"body":"Greetings!\nThis is our second edition of katzenpost news. There’s been a lot of progress since the last report I posted many months ago.\nFirstly I’d like to mention our future development plans:\nmix and directory authority key agility generative testing for the voting Directory Authority system generative testing for all of the things where appropriate load and performance testing the mix server design and development of an application agnostic mixnet client message oriented protocol library design and development of one or more applications that use our new mixnet protocol client library potentially assist in integration with other software projects that want to use a mixnet transport protocol Our recent accomplishments include:\nEradication of our usage of JOSE/JWS and usage of the golang Jose library. We no longer use JOSE/JWS for signing mix descriptors and directory authority documents. Instead we use the “cert” library I wrote which gives us certificate format agility AND cryptographic algorithmic agility. specification: https://github.com/katzenpost/docs/blob/master/specs/certificate.rst\ngolang implementation: https://github.com/katzenpost/core/tree/master/crypto/cert\nOur mix server now has a language agnostic plugin system for adding mixnet services. We have a modular API that allows you to write new services in golang and staticly compile them into the binary, however this new plugin system allows you to add services using external programs as plugins. These external plugins use gRPC over Unix domain socket to talk to the mix server (Provider). Using these plugins we can make new mixnet protocols that are either one way or strict call and response protocols that use SURBs to send the replies. Here’s the mix server documentation for this new feature: https://github.com/katzenpost/docs/blob/master/handbook/mix_server.rst#external-kaetzchen-plugin-configuration\nHere’s the Kaetzchen specification document which explains a bit how this plugin system works although it doesn’t discuss implementation details: https://github.com/katzenpost/docs/blob/master/specs/kaetzchen.rst\nThis repository contains an “echo service” written in Rust, Golang and Python. Also it contains a plugin to perform crypto currency submissions, the idea being that mixnets can be used to transport a transaction blob to a Provider service which then submits the transaction to the database, the blockchain or whatever:\nhttps://github.com/katzenpost/server_plugins\nwe now have a set of incomplete Katzenpost Handbook documents: https://github.com/katzenpost/docs/blob/master/handbook/index.rst\nMailproxy Client Daemon https://github.com/katzenpost/docs/blob/master/handbook/mailproxy.rst\nKatzenpost Mix Server Infrastructure https://github.com/katzenpost/docs/blob/master/handbook/mix_server.rst\nKatzenpost Mix Network Public Key Infrastructure https://github.com/katzenpost/docs/blob/master/handbook/nonvoting_pki.rst\nTorification of Katzenpost https://github.com/katzenpost/docs/blob/master/handbook/tor.rst\nKatzenpost Voting Directory Authority https://github.com/katzenpost/docs/blob/master/handbook/voting_pki.rst\nwe now have a HACKING guide for new Katzenpost developers: https://github.com/katzenpost/docs/blob/master/HACKING/index.rst\nwe now have a release process and some binary releases: https://github.com/katzenpost/docs/blob/master/release_checklist.rst https://github.com/katzenpost/docs/blob/master/releases.rst https://github.com/katzenpost/daemons/releases\nWe have released the voting Directory Authority (mixnet PKI) implementation since it is known to work properly as far as we were able to test thus far. This was more work and more difficult than we originally anticipated for both design and programming the implementation. The design of this PKI was not fully supported by the Panoramix grant project because our academic collaborators were not under official obligation to work on this given that our three month period of design work officially ended. Thus, we were fortunate to receive their advice anyway.\nOur specification document is rather still rather incomplete unfortunately:\nhttps://github.com/katzenpost/docs/blob/master/specs/pki.rst\nMasala has done most of the development work and together we fixed some bugs in the implementation. The design of our PKI is a synthesis of design ideas that come from some brilliant minds and we’d like to thank Yawning Angel, Claudia Diaz, Ania Piotrowska and Nick Mathewson.\nOur PKI uses a Shared Random Value to seed the randomization of our topology. We’d like to thank George Kandianakis for answering our questions about Tor’s hash based commit and reveal shared random value protocol.\nWhat does randomizing our topology mean? Loopix and Katzenpost use the stratified topology which means that the client’s path selection must select a mix from each layer. This topology is enforced by our mix link layer protocol. The PKI generates and publishes a network consensus document\\ and this specifies which mixes belong in which topology layer.\nWhen one or more mix network layers change such that they only contain mixes operated by a single operators or contain only one mix that is what we mean by imbalanced. “Too few security domains” gives too much control over path selection to one or more mix operators.\nThe voting Directory Authority servers detect these mix outages by the absense of a newly uploaded mix descriptors for the voting round. Upon detecting this threshold event the shared random value is used to seed topology randomization. Claudia and Ania rightly pointed out that we MUST try to avoid rerandomization, it is detrimental to the anonymity properties of the mix network because it splits each mix’s anonymity set into two. That is, incoming messages for each mix are either from layer X or from layer Y, this topology distinction in message source means that those two categories of messages will not be mixed together and this is what is meant by splitting the anonymity set into two.\nMasala and I fixed a plethora of race conditions in client and server code for both the Directory authority and mix servers.\nI added a prototype mixnet client and server for supporting Adam Langely’s PANDA protocol:\nhttps://github.com/katzenpost/panda\nPANDA was used in Pond, and Pond has sadly been abandoned by it’s creator. I would like there to be many useful mixnet clients, including a kind of “Pond replacement” that can perform key exchanges using PANDA.\nDuring the last section of my mixnet talk at Bornhack 2018 I demonstrated the mixnet PANDA client and server working:\nhttps://www.youtube.com/watch?v=DhBWKWQztdA\nSincerely, David Stainton\n","categories":"","description":"","excerpt":"Greetings!\nThis is our second edition of katzenpost news. There’s been …","ref":"/blog/2018-11-22/","tags":["katzenpost","blog"],"title":"Monthly News Update (Nov 2018)"},{"body":"katzenpost monthly news Greetings!\nThis is our first edition of katzenpost monthly news. I’ll be summarizing recent events from our first hackfest in Athens in early December 2017 to the present.\nWhat we did in Athens:\nsetup a test mix network remote collaboration with Yawning Angel to fix bugs and add features to the server side wrote some basic installation documentation Moritz created and deployed the katzenpost website with glossary and FAQ explored technical issues related to python and java language bindings to golang libraries discussed at length the possibilies for various kinds of mixnet clients Vincent wrote a prototype android instant messenger client met with the GrNet people and told them how to install a katzenpost mix network and answered their questions meskio and kaliy added an external user db interface for Provider authentication meskio wrote prototype python clients for testing purposes we had many group discussion about mix network design special guest visitor: George Kadianakis from Tor Project Since that time we have been working on our PKI specification. Nick Mathewson sent us a six page review of our spec and Yawning sent a two page reply; both of these e-mails contain lots of design details and have been useful in our editing of the spec thus far:\nhttps://github.com/katzenpost/docs/blob/master/specs/pki.txt\nAdditionally since the Athens hackfest I, masala and Yawning have made changes so that interaction with the nonvoting PKI to NOT use HTTP but instead uses our Noise based wire protocol (which incidentally uses a Post Quantum hybrid key exchange). The PKI spec has been updated with these new changes. If you are curious about our wire protocol you can read about it here:\nhttps://github.com/katzenpost/docs/blob/master/specs/wire-protocol.txt\nDuring the Brussels hackfest we:\nworked on our Google Summer of Code project submission AND additional work on our website: https://katzenpost.mixnetworks.org/contribute.html https://github.com/katzenpost/mixnet_uprising/wiki/Project-Ideas\nkwadronaut and I used a server on our test mixnet to test out Yawning’s new Provider postgres database interface for spool and user authentication databases; Postgres is optional but it is much high performance than boltdb which has no granular transactional locks.\nVincent improved upon the java and python bindings to client library, currently this client library is known as “mailproxy”\nVincent wrote an android k9mail katzenpost prototype for demonstrations\nheld lengthy discussions about autoresponder based keyserver for the purpose of distributing client encryption keys\nwe collectively wrote rough draft specifications for autoresponder services known as kaetzchen and a keyserver:\nautoresponder protocol known as kaetzchen https://github.com/katzenpost/docs/blob/master/drafts/kaetzchen.txt\nkeyserver specification (rough draft) https://github.com/katzenpost/docs/blob/master/drafts/keyserver.txt\nmasala wrote a golang CLI client: https://github.com/katzenpost/demotools/tree/master/cliclient\nmasala worked on making bandwidth overhead estimations of the PKI protocol: https://github.com/mixmasala/docs/blob/mix_bandwidth_estimation/drafts/pki-bandwidth-estimate.txt https://github.com/mixmasala/docs/blob/mix_bandwidth_estimation/tuning/bw.py\nNote: Bandwidth and scaling estimations is something that Nick Mathewson has requested in his review of our PKI specification document.\nhad conversations with several guests at our hackfest including:\nClaudia Diaz video conference with Yawning Angel the developers of sequoia-pgp https://sequoia-pgp.org/ Harry Halpin an associate of Harry who is involved in the crypto currency financial industry Tg created NixOS packages for the katzenpost components https://github.com/katzenpost/nixpkgs\nand NixOS katzenpost configuration for automatic deployment to linux containers: https://github.com/katzenpost/nixops\nmeskio and kaliy: worked on a number of things, including\nLEAP based account registration for katzenpost Providers\nsetup Prometheus to monitor our test mixnet\nperformed stress tests to determine how network load would be affected by various client concurrency levels and bandwidth usage: https://github.com/katzenpost/katzsim\nSince the Brussels hackfest, Masala and I visited Claudia Diaz and Tariq Elahi at KU Leuven to discuss mix network designs. In particular we asked various questions about the AQMs used in the Katzenpost server side and later got clarification from Yawning. We also discussed mix network tuning and learned that the preferred method of tuning mixnets is to run lots of simulations and use different kinds of analysis to determine an appropriate set of tuning parameters.\nDuring this discussion Tariq mentioned that their simulations are likely not using the exact same AQMs as Katzenpost server side. We decided that these simulations could be executed using our “mixnet emulator” which is called kimchi. It runs an entire katzenpost mix network and nonvoting authority in a single golang process.\nWe patiently await for a response to our query: “What features should the mixnet emulator/simulator have?”\nYawning recently implemented the keyserver:\nhttps://github.com/katzenpost/server/blob/master/internal/provider/kaetzchen/keyserver.go\nand the mailproxy client side for interacting with the keyserver:\nhttps://github.com/katzenpost/mailproxy/blob/master/api_kaetzchen.go\nSince then Yawning’s focus has been to improve server side stability and performance. You can see his task list here: https://github.com/orgs/katzenpost/projects/2\nMasala and I have been working on writing a voting directory authority server.\nCurrently our test mixnet works because Yawning has not only written most of the code but he also wrote a nonvoting Directory Authority PKI. However, the nonvoting PKI is not suitable for production use where a decentralized design should be used to achieve the desired security properties.\nBeyond our officially sanctioned work on this project, and in my free time, I’ve been exploring other use-cases for mixnets. I’ve been thinking about “strong location hiding properties”. What I came up with is a kind of kaetzchen dead drop service where you can retreive messages from a remote Provider. The client would never directly interact with the remote Provider but instead only uses the mixnet to retrieve messages.\nhttps://github.com/katzenpost/docs/blob/master/drafts/deaddrop.txt\nCheers!\nDavid\n","categories":"","description":"","excerpt":"katzenpost monthly news Greetings!\nThis is our first edition of …","ref":"/blog/2018-02-27/","tags":["katzenpost","blog"],"title":"Monthly News Update (Feb 2018)"},{"body":" Katzenpost administrator's guideKatzenpost administrator's guideTable of Contents\nIntroduction1. Components and configuration of the Katzenpost mixnetUnderstanding the Katzenpost componentsDirectory authorities (dirauths)Mix nodesGateway nodesService nodesClientsConfiguring KatzenpostConfiguring directory authoritiesConfiguring mix nodesConfiguring gateway nodesConfiguring service nodes2. Using the Katzenpost Docker test networkRequirementsPreparing to run the container imageOperating the test mixnetStarting and monitoring the mixnetTesting the mixnetShutting down the mixnetUninstalling and cleaning upNetwork topology and componentsThe Docker file tree3. Appendix: Configuration files from the Docker test mixnet Directory authorityMix nodeGateway nodeService node4. Appendix: Using gensphinxList of Figures\n1.1. The pictured element types correspond to discrete client and server programs that Katzenpost requires to function. 2.1. Test network topologyList of Tables\n1.1. Katzenpost clients1.2. Directory authority (dirauth) configuration sections1.3. Mix node configuration sections1.4. Gateway node configuration sections1.5. Mix node configuration sections2.1. Table 1: Makefile targets2.2. Table 2: Test mixnet hosts Introduction To Do\nChapter 1. Components and configuration of the Katzenpost mixnetTable of Contents\nUnderstanding the Katzenpost componentsDirectory authorities (dirauths)Mix nodesGateway nodesService nodesClientsConfiguring KatzenpostConfiguring directory authoritiesConfiguring mix nodesConfiguring gateway nodesConfiguring service nodes This section of the Katzenpost technical documentation provides an introduction to the software components that make up Katzenpost and guidance on how to configure each component. The intended reader is a system administrator who wants to implement a working, production Katzenpost network. For information about the theory and design of this software, see Introduction. For a quickly deployable, non-production test network (primarily for use by developers), see Using the Katzenpost Docker test network.\nUnderstanding the Katzenpost components The core of Katzenpost consists of two program executables, dirauth and server. Running the dirauth commmand runs a directory authority node, or dirauth, that functions as part of the mixnet's public-key infrastructure (PKI). Running the server runs either a mix node, a gateway node, or a service node, depending on the configuration. Configuration settings are provided in an associated katzenpost-authority.toml or katzenpost.toml file respectively. In addition to the server components, Katzenpost also supports connections to client applications hosted externally to the mix network and communicating with it through gateway nodes. A model mix network is shown in Figure 1.\nFigure 1.1. The pictured element types correspond to discrete client and server programs that Katzenpost requires to function. The mix network contains an n-layer topology of mix-nodes, with three nodes per layer in this example. Sphinx packets traverse the network in one direction only. The gateway nodes allow clients to interact with the mix network. The service nodes provide mix network services that mix network clients can interact with. All messages sent by clients are handed to a connector daemon hosted on the client system, passed across the Internet to a gateway, and then relayed to a service node by way of the nine mix nodes. The service node sends its reply back across the mix-node layers to a gateway, which transmits it across the Internet to be received by the targeted client. The mix, gateway, and service nodes send mix descriptors to the dirauths and retrieve a consensus document from them, described below.\nIn addition to the server components, Katzenpost supports connections to client applications hosted externally to the mix network and communicating with it through gateway nodes and, in some cases, a client connector.\nDirectory authorities (dirauths) Dirauths compose the decentralized public key infrastructure (PKI) that serves as the root of security for the entire mix network. Clients, mix nodes, gateways nodes, and service nodes rely on the PKI/dirauth system to maintain and sign an up-to-date consensus document, providing a view of the network including connection information and public cryptographic key materials and signatures.\nEvery 20 minutes (the current value for an epoch), each mix, gateway, and service node signs a mix descriptor and uploads it to the dirauths. The dirauths then vote on a new consensus document. If consensus is reached, each dirauth signs the document. Clients and nodes download the document as needed and verify the signatures. Consensus fails when 1/2 + 1 nodes fail, which yields greater fault tolerance than, for example, Byzantine Fault Tolerance, which fails when 1/3 + 1 of the nodes fail.\nThe PKI signature scheme is fully configurable by the dirauths. Our recommendation is to use a hybrid signature scheme consisting of classical Ed25519 and the post-quantum, stateless, hash-based signature scheme known as Sphincs+ (with the parameters: \"sphincs-shake-256f\"), which is designated in Katzenpost configurations as \"Ed25519 Sphincs+\". Examples are provided below.\nMix nodes The mix node is the fundamental building block of the mix network. Katzenpost mix nodes are arranged in a layered topology to achieve the best levels of anonymity and ease of analysis while being flexible enough to scale with traffic demands. Gateway nodes Gateway nodes provide external client access to the mix network. Because gateways are uniquely positioned to identify clients, they are designed to have as little information about client behavior as possible. Gateways are randomly selected and have no persistent relationship with clients and no knowledge of whether a client's packets are decoys or not. When client traffic through a gateway is slow, the node additionally generates decoy traffic. Service nodes Service nodes provide functionality requested by clients. They are logically positioned at the deepest point of the mix network, with incoming queries and outgoing replies both needing to traverse all n layers of mix nodes. A service node's functionality may involve storing messages, publishing information outside of the mixnet, interfacing with a blockchain node, and so on. Service nodes also process decoy packets. Clients Client applications should be designed so that the following conditions are met:\nSeparate service requests from a client are unlinkable. Repeating the same request may be lead to linkability. Service nodes and clients have no persistent relationship.\nCleints generate a stream of packets addressed to random or pseudorandom services regardless of whether a real service request is being made. Most of these packets will be decoy traffic.\nTraffic from a client to a service node must be correctly coupled with decoy traffic. This can mean that the service node is chosen independently from traffic history, or that the transmitted packet replaces a decoy packet that was meant to go to the desired service.\nKatzenpost currently includes several client applications. All applications make extensive use of Sphinx single-use reply blocks (SURBs), which enable service nodes to send replies without knowing the location of the client. Newer clients require a connection through the client connector, which provides multiplexing and privilege separation with a consequent reduction in processing overhead. These clients also implement the Pigeonhole storage and BACAP protocols detailed in Place-holder for research paper link. The following client applications are available.\nTable 1.1. Katzenpost clients\nName\nNeeds connector\nDescription\nCode\nPing\nno\nThe mix network equivalent of an ICMP ping utility, used for network testing.\nGitHub: ping\nKatzen\nno\nA text chat client with file-transfer support.\nGitHub: katzen\nStatus\nyes\nAn HTML page containing status information about the mix network.\nGitHub: status\nWorldmap\nyes An HTML page with a world map showing geographic locations of mix network nodes. GitHub: worldmap\nConfiguring Katzenpost This section documents the configuration parameters for each type of Katzenpost server node. Each node has its own configuration file in TOML format. Configuring directory authorities The following configuration is drawn from the reference implementation in katzenpost/docker/dirauth_mixnet/auth1/authority.toml. In a real-world mixnet, the component hosts would not be sharing a single IP address. For more information about the test mixnet, see Using the Katzenpost Docker test network.\nTable 1.2. Directory authority (dirauth) configuration sections\nDirauth: Server section\nDirauth: Authorities section\nDirauth: Logging section\nDirauth: Parameters section\nDirauth: Debug section\nDirauth: Mixes sections\nDirauth: GatewayNodes section\nDirauth: ServiceNodes sections\nDirauth: Topology section\nDirauth: SphinxGeometry section\nDirauth: Server section The Server section configures mandatory basic parameters for each directory authority.\n[Server] Identifier = \"auth1\" WireKEMScheme = \"xwing\" PKISignatureScheme = \"Ed25519 Sphincs+\" Addresses = [\"tcp://127.0.0.1:30001\"] DataDir = \"/dirauth_mixnet/auth1\" Identifier\nSpecifies the human-readable identifier for a node, and must be unique per mixnet. The identifier can be an FQDN but does not have to be.\nType: string\nRequired: Yes\nWireKEMScheme\nSpecifies the key encapsulation mechanism (KEM) scheme for the PQ Noise-based wire protocol (link layer) that nodes use to communicate with each other. PQ Noise is a post-quantum variation of the Noise protocol framework, which algebraically transforms ECDH handshake patterns into KEM encapsulate/decapsulate operations.\nThis configuration option supports the optional use of hybrid post-quantum cryptography to strengthen security. The following KEM schemes are supported: Classical: \"x25519\", \"x448\"\nNote X25519 and X448 are actually non-interactive key-exchanges (NIKEs), not KEMs. Katzenpost uses a hashed ElGamal cryptographic construction to convert them from NIKEs to KEMs.\nHybrid post-quantum: \"mlkem768\", \"sntrup4591761\", \"frodo640shake\", \"mceliece348864\", \"mceliece348864f\", \"mceliece460896\", \"mceliece460896f\", \"mceliece6688128\", \"mceliece6688128f\", \"mceliece6960119\", \"mceliece6960119f\", \"mceliece8192128\", \"mceliece8192128f\", \"xwing\", \"Kyber768-X25519\", \"MLKEM768-X25519\", \"MLKEM768-X448\", \"CTIDH511\", \"CTIDH512\", \"CTIDH1024\", \"CTIDH2048\", \"CTIDH512-X25519\", \"CTIDH512-X25519\"\nType: string\nRequired: Yes\nPKISignatureScheme\nSpecifies the cryptographic signature scheme which will be used by all components of the mix network when interacting with the PKI system. Mix nodes sign their descriptors using this signature scheme, and dirauth nodes similarly sign PKI documents using the same scheme.\nThe following signature schemes are supported: \"ed25519\", \"ed448\", \"Ed25519 Sphincs+\", \"Ed448-Sphincs+\", \"Ed25519-Dilithium2\", \"Ed448-Dilithium3\" Type: string\nRequired: Yes\nAddresses\nSpecifies a list of one or more address URLs in a format that contains the transport protocol, IP address, and port number that the node will bind to for incoming connections. Katzenpost supports URLs with that start with either \"tcp://\" or \"quic://\" such as: [\"tcp://192.168.1.1:30001\"] and [\"quic://192.168.1.1:40001\"].\nType: []string\nRequired: Yes\nDataDir\nSpecifies the absolute path to a node's state directory. This is where persistence.db is written to disk and where a node stores its cryptographic key materials when started with the \"-g\" command-line option.\nType: string\nRequired: Yes\nDirauth: Authorities section An Authorities section is configured for each peer authority. We recommend using TOML's style for multi-line quotations for key materials.\n[[Authorities]] Identifier = \"auth1\" IdentityPublicKey = \"\"\" -----BEGIN ED25519 PUBLIC KEY----- dYpXpbozjFfqhR45ZC2q97SOOsXMANdHaEdXrP42CJk= -----END ED25519 PUBLIC KEY----- \"\"\" PKISignatureScheme = \"Ed25519\" LinkPublicKey = \"\"\" -----BEGIN XWING PUBLIC KEY----- ooQBPYNdmfwnxXmvnljPA2mG5gWgurfHhbY87DMRY2tbMeZpinJ5BlSiIecprnmm QqxcS9o36IS62SVMlOUkw+XEZGVvc9wJqHpgEgVJRAs1PCR8cUAdM6QIYLWt/lkf SPKDCtZ3GiSIOzMuaglo2tarIPEv1AY7r9B0xXOgSKMkGyBkCfw1VBZf46MM26NL ... gHtNyQJnXski52O03JpZRIhR40pFOhAAcMMAZDpMTVoxlcdR6WA4SlBiSceeJBgY Yp9PlGhCimx9am99TrdLoLCdTHB6oowt8tss3POpIOxaSlguyeym/sBhkUrnXOgN ldMtDsvvc9KUfE4I0+c+XQ== -----END XWING PUBLIC KEY----- \"\"\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30001\"] Identifier\nSpecifies the human-readable identifier for the node which must be unique per mixnet. The identifier can be an FQDN but does not have to be.\nType: string\nRequired: Yes\nIdentityPublicKey\nString containing the node's public identity key in PEM format. IdentityPublicKey is the node's permanent identifier and is used to verify cryptographic signatures produced by its private identity key.\nType: string\nRequired: Yes\nPKISignatureScheme\nSpecifies the cryptographic signature scheme used by all directory authority nodes. PKISignatureScheme must match the scheme specified in the Server section of the configuration. Type: string\nRequired: Yes\nLinkPublicKey\nString containing the peer's public link-layer key in PEM format. LinkPublicKey must match the specified WireKEMScheme.\nType: string\nRequired: Yes\nWireKEMScheme\nSpecifies the key encapsulation mechanism (KEM) scheme for the PQ Noise-based wire protocol (link layer) that nodes use to communicate with each other. PQ Noise is a post-quantum variation of the Noise protocol framework, which algebraically transforms ECDH handshake patterns into KEM encapsulate/decapsulate operations.\nThis configuration option supports the optional use of hybrid post-quantum cryptography to strengthen security. The following KEM schemes are supported: Classical: \"x25519\", \"x448\"\nNote X25519 and X448 are actually non-interactive key-exchanges (NIKEs), not KEMs. Katzenpost uses a hashed ElGamal cryptographic construction to convert them from NIKEs to KEMs.\nHybrid post-quantum: \"mlkem768\", \"sntrup4591761\", \"frodo640shake\", \"mceliece348864\", \"mceliece348864f\", \"mceliece460896\", \"mceliece460896f\", \"mceliece6688128\", \"mceliece6688128f\", \"mceliece6960119\", \"mceliece6960119f\", \"mceliece8192128\", \"mceliece8192128f\", \"xwing\", \"Kyber768-X25519\", \"MLKEM768-X25519\", \"MLKEM768-X448\", \"CTIDH511\", \"CTIDH512\", \"CTIDH1024\", \"CTIDH2048\", \"CTIDH512-X25519\", \"CTIDH512-X25519\"\nType: string\nRequired: Yes\nAddresses\nSpecifies a list of one or more address URLs in a format that contains the transport protocol, IP address, and port number that the node will bind to for incoming connections. Katzenpost supports URLs with that start with either \"tcp://\" or \"quic://\" such as: [\"tcp://192.168.1.1:30001\"] and [\"quic://192.168.1.1:40001\"].\nType: []string\nRequired: Yes\nDirauth: Logging section The Logging configuration section controls logging behavior across Katzenpost.\n[Logging] Disable = false File = \"katzenpost.log\" Level = \"INFO\" Disable\nIf true, logging is disabled.\nType: bool\nRequired: No\nFile\nSpecifies the log file. If omitted, stdout is used.\nAn absolute or relative file path can be specified. A relative path is relative to the DataDir specified in the Server section of the configuration.\nType: string\nRequired: No\nLevel\nSupported logging level values are ERROR | WARNING | NOTICE |INFO | DEBUG.\nType: string\nRequired: No\nWarning The DEBUG log level is unsafe for production use.\nDirauth: Parameters section The Parameters section contains the network parameters.\n[Parameters] SendRatePerMinute = 0 Mu = 0.005 MuMaxDelay = 1000 LambdaP = 0.001 LambdaPMaxDelay = 1000 LambdaL = 0.0005 LambdaLMaxDelay = 1000 LambdaD = 0.0005 LambdaDMaxDelay = 3000 LambdaM = 0.0005 LambdaG = 0.0 LambdaMMaxDelay = 100 LambdaGMaxDelay = 100 SendRatePerMinute\nSpecifies the maximum allowed rate of packets per client per gateway node. Rate limiting is done on the gateway nodes.\nType: uint64\nRequired: Yes\nMu\nSpecifies the inverse of the mean of the exponential distribution from which the Sphinx packet per-hop mixing delay will be sampled.\nType: float64\nRequired: Yes\nMuMaxDelay\nSpecifies the maximum Sphinx packet per-hop mixing delay in milliseconds. Type: uint64\nRequired: Yes\nLambdaP\nSpecifies the inverse of the mean of the exponential distribution that clients sample to determine the time interval between sending messages, whether actual messages from the FIFO egress queue or decoy messages if the queue is empty.\nType: float64\nRequired: Yes\nLambdaPMaxDelay\nSpecifies the maximum send delay interval for LambdaP in milliseconds.\nType: uint64\nRequired: Yes\nLambdaL\nSpecifies the inverse of the mean of the exponential distribution that clients sample to determine the delay interval between loop decoys.\nType: float64\nRequired: Yes\nLambdaLMaxDelay\nSpecifies the maximum send delay interval for LambdaL in milliseconds.\nType: uint64\nRequired: Yes\nLambdaD\nLambdaD is the inverse of the mean of the exponential distribution that clients sample to determine the delay interval between decoy drop messages. Type: float64\nRequired: Yes\nLambdaDMaxDelay\nSpecifies the maximum send interval in for LambdaD in milliseconds. Type: uint64\nRequired: Yes\nLambdaM\nLambdaM is the inverse of the mean of the exponential distribution that mix nodes sample to determine the delay between mix loop decoys.\nType: float64\nRequired: Yes\nLambdaG\nLambdaG is the inverse of the mean of the exponential distribution that gateway nodes to select the delay between gateway node decoys.\nWarning Do not set this value manually in the TOML configuration file. The field is used internally by the dirauth server state machine.\nType: float64\nRequired: Yes\nLambdaMMaxDelay\nSpecifies the maximum delay for LambdaM in milliseconds.\nType: uint64\nRequired: Yes\nLambdaGMaxDelay\nSpecifies the maximum delay for LambdaG in milliseconds.\nType: uint64\nRequired: Yes\nDirauth: Debug section [Debug] Layers = 3 MinNodesPerLayer = 1 GenerateOnly = false Layers\nSpecifies the number of non-service-provider layers in the network topology.\nType: int\nRequired: Yes\nMinNodesrPerLayer\nSpecifies the minimum number of nodes per layer required to form a valid consensus document.\nType: int\nRequired: Yes\nGenerateOnly\nIf true, the server halts and cleans up the data directory immediately after long-term key generation.\nType: bool\nRequired: No\nDirauth: Mixes sections The Mixes configuration sections list mix nodes that are known to the authority.\n[[Mixes]] Identifier = \"mix1\" IdentityPublicKeyPem = \"../mix1/identity.public.pem\" [[Mixes]] Identifier = \"mix2\" IdentityPublicKeyPem = \"../mix2/identity.public.pem\" [[Mixes]] Identifier = \"mix3\" IdentityPublicKeyPem = \"../mix3/identity.public.pem\" Identifier\nSpecifies the human-readable identifier for a mix node, and must be unique per mixnet. The identifier can be an FQDN but does not have to be.\nType: string\nRequired: Yes\nIdentityPublicKeyPem\nPath and file name of a mix node's public identity signing key, also known as the identity key, in PEM format.\nType: string\nRequired: Yes\nDirauth: GatewayNodes section The GatewayNodes sections list gateway nodes that are known to the authority.\n[[GatewayNodes]] Identifier = \"gateway1\" IdentityPublicKeyPem = \"../gateway1/identity.public.pem\" Identifier\nSpecifies the human-readable identifier for a gateway node, and must be unique per mixnet. Identifier can be an FQDN but does not have to be.\nType: string\nRequired: Yes\nIdentityPublicKeyPem\nPath and file name of a gateway node's public identity signing key, also known as the identity key, in PEM format.\nType: string\nRequired: Yes\nDirauth: ServiceNodes sections The ServiceNodes sections list service nodes that are known to the authority.\n[[ServiceNodes]] Identifier = \"servicenode1\" IdentityPublicKeyPem = \"../servicenode1/identity.public.pem\" Identifier\nSpecifies the human-readable identifier for a service node, and must be unique per mixnet. Identifier can be an FQDN but does not have to be.\nType: string\nRequired: Yes\nIdentityPublicKeyPem\nPath and file name of a service node's public identity signing key, also known as the identity key, in PEM format.\nType: string\nRequired: Yes\nDirauth: Topology section The Topology section defines the layers of the mix network and the mix nodes in each layer.\n[Topology] [[Topology.Layers]] [[Topology.Layers.Nodes]] Identifier = \"mix1\" IdentityPublicKeyPem = \"../mix1/identity.public.pem\" [[Topology.Layers]] [[Topology.Layers.Nodes]] Identifier = \"mix2\" IdentityPublicKeyPem = \"../mix2/identity.public.pem\" [[Topology.Layers]] [[Topology.Layers.Nodes]] Identifier = \"mix3\" IdentityPublicKeyPem = \"../mix3/identity.public.pem\" Identifier\nSpecifies the human-readable identifier for a node, and must be unique per mixnet. The identifier can be an FQDN but does not have to be.\nType: string\nIdentityPublicKeyPem\nPath and file name of a mix node's public identity signing key, also known as the identity key, in PEM format.\nType: string\nRequired: Yes\nDirauth: SphinxGeometry section Sphinx is an encrypted nested-packet format designed primarily for mixnets. The original Sphinx paper described a non-interactive key exchange (NIKE) employing classical encryption. The Katzenpost implementation strongly emphasizes configurability, supporting key encapsulation mechanisms (KEMs) as well as NIKEs, and enabling the use of either classical or hybrid post-quantum cryptography. Hybrid constructions offset the newness of post-quantum algorithms by offering heavily tested classical algorithms as a fallback.\nNote Sphinx, the nested-packet format, should not be confused with Sphincs or Sphincs+, which are post-quantum signature schemes.\nKatzenpost Sphinx also relies on the following classical cryptographic primitives: CTR-AES256, a stream cipher\nHMAC-SHA256, a message authentication code (MAC) function\nHKDF-SHA256, a key derivation function (KDF)\nAEZv5, a strong pseudorandom permutation (SPRP)\nAll dirauths must be configured to use the same SphinxGeometry parameters. Any geometry not advertised by the PKI document will fail. Each dirauth publishes the hash of its SphinxGeometry parameters in the PKI document for validation by its peer dirauths. The SphinxGeometry section defines parameters for the Sphinx encrypted nested-packet format used internally by Katzenpost. WarningThe values in the SphinxGeometry configuration section must be programmatically generated by gensphinx. Many of the parameters are interdependent and cannot be individually modified. Do not modify the these values by hand.\nThe settings in this section are generated by the gensphinx utility, which computes the Sphinx geometry based on the following user-supplied directives:\nThe number of mix node layers (not counting gateway and service nodes)\nThe length of the application-usable packet payload\nThe selected NIKE or KEM scheme\nThe output in TOML should then be pasted unchanged into the node's configuration file, as shown below. For more information, see Chapter 4, Appendix: Using gensphinx.\n[SphinxGeometry] PacketLength = 3082 NrHops = 5 HeaderLength = 476 RoutingInfoLength = 410 PerHopRoutingInfoLength = 82 SURBLength = 572 SphinxPlaintextHeaderLength = 2 PayloadTagLength = 32 ForwardPayloadLength = 2574 UserForwardPayloadLength = 2000 NextNodeHopLength = 65 SPRPKeyMaterialLength = 64 NIKEName = \"x25519\" KEMName = \"\" PacketLength\nThe length of a Sphinx packet in bytes.\nType: int\nRequired: Yes\nNrHops\nThe number of hops a Sphinx packet takes through the mixnet. Because packet headers hold destination information for each hop, the size of the header increases linearly with the number of hops.\nType: int\nRequired: Yes\nHeaderLength\nThe total length of the Sphinx packet header in bytes.\nType: int\nRequired: Yes\nRoutingInfoLength\nThe total length of the routing information portion of the Sphinx packet header.\nType: int\nRequired: Yes\nPerHopRoutingInfoLength\nThe length of the per-hop routing information in the Sphinx packet header.\nType: int\nRequired: Yes\nSURBLength\nThe length of a single-use reply block (SURB).\nType: int\nRequired: Yes\nSphinxPlaintextHeaderLength\nThe length of the plaintext Sphinx packet header.\nType: int\nRequired: Yes\nPayloadTagLength\nThe length of the payload tag.\nType: int\nRequired: Yes\nForwardPayloadLength\nThe total size of the payload.\nType: int\nRequired: Yes\nUserForwardPayloadLength\nThe size of the usable payload.\nType: int\nRequired: Yes\nNextNodeHopLength\nThe NextNodeHopLength is derived from the largest routing-information block that we expect to encounter. Other packets have NextNodeHop + NodeDelay sections, or a Recipient section, both of which are shorter.\nType: int\nRequired: Yes\nSPRPKeyMaterialLength\nThe length of the strong pseudo-random permutation (SPRP) key.\nType: int\nRequired: Yes\nNIKEName\nThe name of the non-interactive key exchange (NIKE) scheme used by Sphinx packets.\nNIKEName and KEMName are mutually exclusive.\nType: string\nRequired: Yes\nKEMName\nThe name of the key encapsulation mechanism (KEM) used by Sphinx packets.\nNIKEName and KEMName are mutually exclusive.\nType: string\nRequired: Yes\nConfiguring mix nodes The following configuration is drawn from the reference implementation in katzenpost/docker/dirauth_mixnet/mix1/katzenpost.toml. In a real-world mixnet, the component hosts would not be sharing a single IP address. For more information about the test mixnet, see Using the Katzenpost Docker test network.\nTable 1.3. Mix node configuration sections\nMix node: Server section\nMix node: Logging section\nMix node: PKI section\nMix node: Management section\nMix node: SphinxGeometry section\nMix node: Debug section\nMix node: Server section The Server section configures mandatory basic parameters for each server node.\n[Server] Identifier = \"mix1\" WireKEM = \"xwing\" PKISignatureScheme = \"Ed25519\" Addresses = [\"127.0.0.1:30008\"] OnlyAdvertiseAltAddresses = false MetricsAddress = \"127.0.0.1:30009\" DataDir = \"/dirauth_mixnet/mix1\" IsGatewayNode = false IsServiceNode = false [Server.AltAddresses] Identifier\nSpecifies the human-readable identifier for a node, and must be unique per mixnet. The identifier can be an FQDN but does not have to be.\nType: string\nRequired: Yes\nWireKEM\nWireKEM specifies the key encapsulation mechanism (KEM) scheme for the PQ Noise-based wire protocol (link layer) that nodes use to communicate with each other. PQ Noise is a post-quantum variation of the Noise protocol framework, which algebraically transforms ECDH handshake patterns into KEM encapsulate/decapsulate operations.\nThis configuration option supports the optional use of hybrid post-quantum cryptography to strengthen security. The following KEM schemes are supported: Classical: \"x25519\", \"x448\"\nNoteX25519 and X448 are actually non-interactive key-exchanges (NIKEs), not KEMs. Katzenpost uses a Hashed ElGamal cryptographic construction to convert them from NIKEs to KEMs.\nHybrid post-quantum: \"mlkem768\", \"sntrup4591761\", \"frodo640shake\", \"mceliece348864\", \"mceliece348864f\", \"mceliece460896\", \"mceliece460896f\", \"mceliece6688128\", \"mceliece6688128f\", \"mceliece6960119\", \"mceliece6960119f\", \"mceliece8192128\", \"mceliece8192128f\", \"xwing\", \"Kyber768-X25519\", \"MLKEM768-X25519\", \"MLKEM768-X448\", \"CTIDH511\", \"CTIDH512\", \"CTIDH1024\", \"CTIDH2048\", \"CTIDH512-X25519\", \"CTIDH512-X25519\"\nType: string\nRequired: Yes\nPKISignatureScheme\nSpecifies the cryptographic signature scheme that will be used by all components of the mix network when interacting with the PKI system. Mix nodes sign their descriptors using this signature scheme, and dirauth nodes similarly sign PKI documents using the same scheme.\nThe following signature schemes are supported:\nClassical: \"ed25519\", \"ed448\"\nHybrid post-quantum: \"Ed25519 Sphincs+\", \"Ed448-Sphincs+\", \"Ed25519-Dilithium2\", \"Ed448-Dilithium3\" Type: string\nRequired: Yes\nAddresses\nSpecifies a list of one or more address URLs in a format that contains the transport protocol, IP address, and port number that the server will bind to for incoming connections. Katzenpost supports URLs with that start with either \"tcp://\" or \"quic://\" such as: [\"tcp://192.168.1.1:30001\"] and [\"quic://192.168.1.1:40001\"].\nType: []string\nRequired: Yes\nBindAddresses\nIf true, allows setting of listener addresses that the server will bind to and accept connections on. These addresses are not advertised in the PKI.\nType: bool\nRequired: No\nMetricsAddress\nSpecifies the address/port to bind the Prometheus metrics endpoint to.\nType: string\nRequired: No\nDataDir\nSpecifies the absolute path to a node's state directory. This is where persistence.db is written to disk and where a node stores its cryptographic key materials when started with the \"-g\" commmand-line option.\nType: string\nRequired: Yes\nIsGatewayNode\nIf true, the server is a gateway node.\nType: bool\nRequired: No\nIsServiceNode\nIf true, the server is a service node.\nType: bool\nRequired: No\nMix node: Logging section The Logging configuration section controls logging behavior across Katzenpost.\n[Logging] Disable = false File = \"katzenpost.log\" Level = \"INFO\" Disable\nIf true, logging is disabled.\nType: bool\nRequired: No\nFile\nSpecifies the log file. If omitted, stdout is used.\nAn absolute or relative file path can be specified. A relative path is relative to the DataDir specified in the Server section of the configuration.\nType: string\nRequired: No\nLevel\nSupported logging level values are ERROR | WARNING | NOTICE |INFO | DEBUG.\nType: string\nRequired: No\nWarning The DEBUG log level is unsafe for production use.\nMix node: PKI section The PKI section contains the directory authority configuration for a mix, gateway, or service node.\n[PKI] [PKI.dirauth] [[PKI.dirauth.Authorities]] Identifier = \"auth1\" IdentityPublicKey = \"\"\"-----BEGIN ED25519 PUBLIC KEY----- tqN6tpOVotHWXKCszVn2kS7vAZjQpvJjQF3Qz/Qwhyg= -----END ED25519 PUBLIC KEY----- \"\"\" PKISignatureScheme = \"Ed25519\" LinkPublicKey = \"\"\"-----BEGIN XWING PUBLIC KEY----- JnJ8ztQEIjAkKJcpuZvJAdkWjBim/5G5d8yoosEQHeGJeeBqNPdm2AitUbpiQPcd tNCo9DxuC9Ieqmsfw0YpV6AtOOsaInA6QnHDYcuBfZcQL5MU4+t2TzpBZQYlrSED hPCKrAG+8GEUl6akseG371WQzEtPpEWWCJCJOiS/VDFZT7eKrldlumN6gfiB84sR ... arFh/WKwYJUj+aGBsFYSqGdzC6MdY4x/YyFe2ze0MJEjThQE91y1d/LCQ3Sb7Ri+ u6PBi3JU2qzlPEejDKwK0t5tMNEAkq8iNrpRTdD/hS0gR+ZIN8Z9QKh7Xf94FWG2 H+r8OaqImQhgHabrWRDyLg== -----END XWING PUBLIC KEY----- \"\"\" WireKEMScheme = \"xwing\" Addresses = [\"127.0.0.1:30001\"] [[PKI.dirauth.Authorities]] Identifier = \"auth2\" IdentityPublicKey = \"\"\"-----BEGIN ED25519 PUBLIC KEY----- O51Ty2WLu4C1ETMa29s03bMXV72gnjJfTfwLV++LVBI= -----END ED25519 PUBLIC KEY-----\t\"\"\" PKISignatureScheme = \"Ed25519\" LinkPublicKey = \"\"\"-----BEGIN XWING PUBLIC KEY----- TtQkg2XKUnY602FFBaPJ+zpN0Twy20cwyyFxh7FNUjaXA9MAJXs0vUwFbJc6BjYv f+olKnlIKFSmDvcF74U6w1F0ObugwTNKNxeYKPKhX4FiencUbRwkHoYHdtZdSctz TKy08qKQyCAccqCRpdo6ZtYXPAU+2rthjYTOL7Zn+7SHUKCuJClcPnvEYjVcJxtZ ... ubJIe5U4nMJbBkOqr7Kq6niaEkiLODa0tkpB8tKMYTMBdcYyHSXCzpo7U9sb6LAR HktiTBDtRXviu2vbw7VRXhkMW2kjYZDtReQ5sAse04DvmD49zgTp1YxYW+wWFaL3 37X7/SNuLdHX4PHZXIWHBQ== -----END XWING PUBLIC KEY-----\t\"\"\" WireKEMScheme = \"xwing\" Addresses = [\"127.0.0.1:30002\"] [[PKI.dirauth.Authorities]] Identifier = \"auth3\" IdentityPublicKey = \"\"\"-----BEGIN ED25519 PUBLIC KEY----- zQvydRYJq3npeLcg1NqIf+SswEKE5wFmiwNsI9Z1whQ= -----END ED25519 PUBLIC KEY----- \"\"\" PKISignatureScheme = \"Ed25519\" LinkPublicKey = \"\"\" -----BEGIN XWING PUBLIC KEY----- OYK9FiC53xwZ1VST3jDOO4tR+cUMSVRSekmigZMChSjDCPZbKut8TblxtlUfc/yi Ugorz4NIvYPMWUt3QPwS2UWq8/HMWXNGPUiAevg12+oV+jOJXaJeCfY24UekJnSw TNcdGaFZFSR0FocFcPBBnrK1M2B8w8eEUKQIsXRDM3x/8aRIuDif+ve8rSwpgKeh ... OdVD3yw7OOS8uPZLORGQFyJbHtVmFPVvwja4G/o2gntAoHUZ2LiJJakpVhhlSyrI yuzvwwFtZVfWtNb5gAKZCyg0aduR3qgd7MPerRF+YopZk3OCRpC02YxfUZrHv398 FZWJFK0R8iU52CEUxVpXTA== -----END XWING PUBLIC KEY-----\t\"\"\" WireKEMScheme = \"xwing\" Addresses = [\"127.0.0.1:30003\"] Identifier\nSpecifies the human-readable identifier for a node, which must be unique per mixnet. The identifier can be an FQDN but does not have to be.\nType: string\nRequired: Yes\nIdentityPublicKey\nString containing the node's public identity key in PEM format. IdentityPublicKey is the node's permanent identifier and is used to verify cryptographic signatures produced by its private identity key.\nType: string\nRequired: Yes\nPKISignatureScheme\nSpecifies the cryptographic signature scheme that will be used by all components of the mix network when interacting with the PKI system. Mix nodes sign their descriptors using this signature scheme, and dirauth nodes similarly sign PKI documents using the same scheme.\nType: string\nRequired: Yes\nLinkPublicKey\nString containing the peer's public link-layer key in PEM format. LinkPublicKey must match the specified WireKEMScheme.\nType: string\nRequired: Yes\nWireKEMScheme\nThe name of the wire protocol key-encapsulation mechanism (KEM) to use.\nType: string\nRequired: Yes\nAddresses\nSpecifies a list of one or more address URLs in a format that contains the transport protocol, IP address, and port number that the server will bind to for incoming connections. Katzenpost supports URLs that start with either \"tcp://\" or \"quic://\" such as: [\"tcp://192.168.1.1:30001\"] and [\"quic://192.168.1.1:40001\"].\nType: []string\nRequired: Yes\nMix node: Management section The Management section specifies connectivity information for the Katzenpost control protocol which can be used to make run-time configuration changes. A configuration resembles the following:\n[Management] Enable = false Path = \"/dirauth_mixnet/mix1/management_sock\" Enable\nIf true, the management interface is enabled.\nType: bool\nRequired: No\nPath\nSpecifies the path to the management interface socket. If left empty, then management_sock is located in the configuration's defined DataDir\u003e.\nType: string\nRequired: No\nMix node: SphinxGeometry section The SphinxGeometry section defines parameters for the Sphinx encrypted nested-packet format used internally by Katzenpost. WarningThe values in the SphinxGeometry configuration section must be programmatically generated by gensphinx. Many of the parameters are interdependent and cannot be individually modified. Do not modify the these values by hand.\nThe settings in this section are generated by the gensphinx utility, which computes the Sphinx geometry based on the following user-supplied directives:\nThe number of mix node layers (not counting gateway and service nodes)\nThe length of the application-usable packet payload\nThe selected NIKE or KEM scheme\nThe output in TOML should then be pasted unchanged into the node's configuration file, as shown below. For more information, see Chapter 4, Appendix: Using gensphinx.\n[SphinxGeometry] PacketLength = 3082 NrHops = 5 HeaderLength = 476 RoutingInfoLength = 410 PerHopRoutingInfoLength = 82 SURBLength = 572 SphinxPlaintextHeaderLength = 2 PayloadTagLength = 32 ForwardPayloadLength = 2574 UserForwardPayloadLength = 2000 NextNodeHopLength = 65 SPRPKeyMaterialLength = 64 NIKEName = \"x25519\" KEMName = \"\" PacketLength\nThe length of a Sphinx packet in bytes.\nType: int\nRequired: Yes\nNrHops\nThe number of hops a Sphinx packet takes through the mixnet. Because packet headers hold destination information for each hop, the size of the header increases linearly with the number of hops.\nType: int\nRequired: Yes\nHeaderLength\nThe total length of the Sphinx packet header in bytes.\nType: int\nRequired: Yes\nRoutingInfoLength\nThe total length of the routing information portion of the Sphinx packet header.\nType: int\nRequired: Yes\nPerHopRoutingInfoLength\nThe length of the per-hop routing information in the Sphinx packet header.\nType: int\nRequired: Yes\nSURBLength\nThe length of a single-use reply block (SURB).\nType: int\nRequired: Yes\nSphinxPlaintextHeaderLength\nThe length of the plaintext Sphinx packet header.\nType: int\nRequired: Yes\nPayloadTagLength\nThe length of the payload tag.\nType: int\nRequired: Yes\nForwardPayloadLength\nThe total size of the payload.\nType: int\nRequired: Yes\nUserForwardPayloadLength\nThe size of the usable payload.\nType: int\nRequired: Yes\nNextNodeHopLength\nThe NextNodeHopLength is derived from the largest routing-information block that we expect to encounter. Other packets have NextNodeHop + NodeDelay sections, or a Recipient section, both of which are shorter.\nType: int\nRequired: Yes\nSPRPKeyMaterialLength\nThe length of the strong pseudo-random permutation (SPRP) key.\nType: int\nRequired: Yes\nNIKEName\nThe name of the non-interactive key exchange (NIKE) scheme used by Sphinx packets.\nNIKEName and KEMName are mutually exclusive.\nType: string\nRequired: Yes\nKEMName\nThe name of the key encapsulation mechanism (KEM) used by Sphinx packets.\nNIKEName and KEMName are mutually exclusive.\nType: string\nRequired: Yes\nMix node: Debug section The Debug section is the Katzenpost server debug configuration for advanced tuning.\n[Debug] NumSphinxWorkers = 16 NumServiceWorkers = 3 NumGatewayWorkers = 3 NumKaetzchenWorkers = 3 SchedulerExternalMemoryQueue = false SchedulerQueueSize = 0 SchedulerMaxBurst = 16 UnwrapDelay = 250 GatewayDelay = 500 ServiceDelay = 500 KaetzchenDelay = 750 SchedulerSlack = 150 SendSlack = 50 DecoySlack = 15000 ConnectTimeout = 60000 HandshakeTimeout = 30000 ReauthInterval = 30000 SendDecoyTraffic = false DisableRateLimit = false GenerateOnly = false NumSphinxWorkers\nSpecifies the number of worker instances to use for inbound Sphinx packet processing.\nType: int\nRequired: No\nNumProviderWorkers\nSpecifies the number of worker instances to use for provider specific packet processing.\nType: int\nRequired: No\nNumKaetzchenWorkers\nSpecifies the number of worker instances to use for Kaetzchen-specific packet processing.\nType: int\nRequired: No\nSchedulerExternalMemoryQueue\nIf true, the experimental disk-backed external memory queue is enabled.\nType: bool\nRequired: No\nSchedulerQueueSize\nSpecifies the maximum scheduler queue size before random entries will start getting dropped. A value less than or equal to zero is treated as unlimited.\nType: int\nRequired: No\nSchedulerMaxBurst\nSpecifies the maximum number of packets that will be dispatched per scheduler wakeup event.\nType: Required: No\nUnwrapDelay\nSpecifies the maximum unwrap delay due to queueing in milliseconds.\nType: int\nRequired: No\nGatewayDelay\nSpecifies the maximum gateway node worker delay due to queueing in milliseconds.\nType: int\nRequired: No\nServiceDelay\nSpecifies the maximum provider delay due to queueing in milliseconds.\nType: int\nRequired: No\nKaetzchenDelay\nSpecifies the maximum kaetzchen delay due to queueing in milliseconds.\nType: int\nRequired: No\nSchedulerSlack\nSpecifies the maximum scheduler slack due to queueing and/or processing in milliseconds.\nType: int\nRequired: No\nSendSlack\nSpecifies the maximum send-queue slack due to queueing and/or congestion in milliseconds.\nType: int\nRequired: No\nDecoySlack\nSpecifies the maximum decoy sweep slack due to external delays such as latency before a loop decoy packet will be considered lost.\nType: int\nRequired: No\nConnectTimeout\nSpecifies the maximum time a connection can take to establish a TCP/IP connection in milliseconds.\nType: int\nRequired: No\nHandshakeTimeout\nSpecifies the maximum time a connection can take for a link-protocol handshake in milliseconds.\nType: int\nRequired: No\nReauthInterval\nSpecifies the interval at which a connection will be reauthenticated in milliseconds.\nType: int\nRequired: No\nSendDecoyTraffic\nIf true, decoy traffic is enabled. This parameter is experimental and untuned, and is disabled by default.\nNote This option will be removed once decoy traffic is fully implemented.\nType: bool\nRequired: No\nDisableRateLimit\nIf true, the per-client rate limiter is disabled.\nNote This option should only be used for testing.\nType: bool\nRequired: No\nGenerateOnly\nIf true, the server immediately halts and cleans up after long-term key generation.\nType: bool\nRequired: No\nConfiguring gateway nodes The following configuration is drawn from the reference implementation in katzenpost/docker/dirauth_mixnet/gateway1/katzenpost.toml. In a real-world mixnet, the component hosts would not be sharing a single IP address. For more information about the test mixnet, see Using the Katzenpost Docker test network.\nTable 1.4. Gateway node configuration sections\nGateway node: Server section\nGateway node: Logging section\nGateway node: Gateway section\nGateway node: PKI section\nGateway node: Management section\nGateway node: SphinxGeometry section\nGateway node: Debug section\nGateway node: Server section The Server section configures mandatory basic parameters for each server node.\n[Server] Identifier = \"gateway1\" WireKEM = \"xwing\" PKISignatureScheme = \"Ed25519\" Addresses = [\"127.0.0.1:30004\"] OnlyAdvertiseAltAddresses = false MetricsAddress = \"127.0.0.1:30005\" DataDir = \"/dirauth_mixnet/gateway1\" IsGatewayNode = true IsServiceNode = false [Server.AltAddresses] TCP = [\"localhost:30004\"] Identifier\nSpecifies the human-readable identifier for a node, and must be unique per mixnet. The identifier can be an FQDN but does not have to be.\nType: string\nRequired: Yes\nWireKEM\nWireKEM specifies the key encapsulation mechanism (KEM) scheme for the PQ Noise-based wire protocol (link layer) that nodes use to communicate with each other. PQ Noise is a post-quantum variation of the Noise protocol framework, which algebraically transforms ECDH handshake patterns into KEM encapsulate/decapsulate operations.\nThis configuration option supports the optional use of hybrid post-quantum cryptography to strengthen security. The following KEM schemes are supported: Classical: \"x25519\", \"x448\"\nNoteX25519 and X448 are actually non-interactive key-exchanges (NIKEs), not KEMs. Katzenpost uses a Hashed ElGamal cryptographic construction to convert them from NIKEs to KEMs.\nHybrid post-quantum: \"mlkem768\", \"sntrup4591761\", \"frodo640shake\", \"mceliece348864\", \"mceliece348864f\", \"mceliece460896\", \"mceliece460896f\", \"mceliece6688128\", \"mceliece6688128f\", \"mceliece6960119\", \"mceliece6960119f\", \"mceliece8192128\", \"mceliece8192128f\", \"xwing\", \"Kyber768-X25519\", \"MLKEM768-X25519\", \"MLKEM768-X448\", \"CTIDH511\", \"CTIDH512\", \"CTIDH1024\", \"CTIDH2048\", \"CTIDH512-X25519\", \"CTIDH512-X25519\"\nType: string\nRequired: Yes\nPKISignatureScheme\nSpecifies the cryptographic signature scheme that will be used by all components of the mix network when interacting with the PKI system. Mix nodes sign their descriptors using this signature scheme, and dirauth nodes similarly sign PKI documents using the same scheme.\nThe following signature schemes are supported:\nClassical: \"ed25519\", \"ed448\"\nHybrid post-quantum: \"Ed25519 Sphincs+\", \"Ed448-Sphincs+\", \"Ed25519-Dilithium2\", \"Ed448-Dilithium3\" Type: string\nRequired: Yes\nAddresses\nSpecifies a list of one or more address URLs in a format that contains the transport protocol, IP address, and port number that the server will bind to for incoming connections. Katzenpost supports URLs with that start with either \"tcp://\" or \"quic://\" such as: [\"tcp://192.168.1.1:30001\"] and [\"quic://192.168.1.1:40001\"].\nType: []string\nRequired: Yes\nBindAddresses\nIf true, allows setting of listener addresses that the server will bind to and accept connections on. These addresses are not advertised in the PKI.\nType: bool\nRequired: No\nMetricsAddress\nSpecifies the address/port to bind the Prometheus metrics endpoint to.\nType: string\nRequired: No\nDataDir\nSpecifies the absolute path to a node's state directory. This is where persistence.db is written to disk and where a node stores its cryptographic key materials when started with the \"-g\" commmand-line option.\nType: string\nRequired: Yes\nIsGatewayNode\nIf true, the server is a gateway node.\nType: bool\nRequired: No\nIsServiceNode\nIf true, the server is a service node.\nType: bool\nRequired: No\nGateway node: Logging section The Logging configuration section controls logging behavior across Katzenpost.\n[Logging] Disable = false File = \"katzenpost.log\" Level = \"INFO\" Disable\nIf true, logging is disabled.\nType: bool\nRequired: No\nFile\nSpecifies the log file. If omitted, stdout is used.\nAn absolute or relative file path can be specified. A relative path is relative to the DataDir specified in the Server section of the configuration.\nType: string\nRequired: No\nLevel\nSupported logging level values are ERROR | WARNING | NOTICE |INFO | DEBUG.\nType: string\nRequired: No\nWarning The DEBUG log level is unsafe for production use.\nGateway node: Gateway section The Gateway section of the configuration is required for configuring a Gateway node. The section must contain UserDB and SpoolDB definitions. Bolt is an embedded database library for the Go programming language that Katzenpost has used in the past for its user and spool databases. Because Katzenpost currently persists data on Service nodes instead of Gateways, these databases will probably be deprecated in favour of in-memory concurrency structures. In the meantime, it remains necessary to configure a Gateway node as shown below, only changing the file paths as needed: [Gateway] [Gateway.UserDB] Backend = \"bolt\" [Gateway.UserDB.Bolt] UserDB = \"/dirauth_mixnet/gateway1/users.db\" [Gateway.SpoolDB] Backend = \"bolt\" [Gateway.SpoolDB.Bolt] SpoolDB = \"/dirauth_mixnet/gateway1/spool.db\" Gateway node: PKI section The PKI section contains the directory authority configuration for a mix, gateway, or service node.\n[PKI] [PKI.dirauth] [[PKI.dirauth.Authorities]] Identifier = \"auth1\" IdentityPublicKey = \"\"\"-----BEGIN ED25519 PUBLIC KEY----- tqN6tpOVotHWXKCszVn2kS7vAZjQpvJjQF3Qz/Qwhyg= -----END ED25519 PUBLIC KEY----- \"\"\" PKISignatureScheme = \"Ed25519\" LinkPublicKey = \"\"\"-----BEGIN XWING PUBLIC KEY----- JnJ8ztQEIjAkKJcpuZvJAdkWjBim/5G5d8yoosEQHeGJeeBqNPdm2AitUbpiQPcd tNCo9DxuC9Ieqmsfw0YpV6AtOOsaInA6QnHDYcuBfZcQL5MU4+t2TzpBZQYlrSED hPCKrAG+8GEUl6akseG371WQzEtPpEWWCJCJOiS/VDFZT7eKrldlumN6gfiB84sR ... arFh/WKwYJUj+aGBsFYSqGdzC6MdY4x/YyFe2ze0MJEjThQE91y1d/LCQ3Sb7Ri+ u6PBi3JU2qzlPEejDKwK0t5tMNEAkq8iNrpRTdD/hS0gR+ZIN8Z9QKh7Xf94FWG2 H+r8OaqImQhgHabrWRDyLg== -----END XWING PUBLIC KEY----- \"\"\" WireKEMScheme = \"xwing\" Addresses = [\"127.0.0.1:30001\"] [[PKI.dirauth.Authorities]] Identifier = \"auth2\" IdentityPublicKey = \"\"\"-----BEGIN ED25519 PUBLIC KEY----- O51Ty2WLu4C1ETMa29s03bMXV72gnjJfTfwLV++LVBI= -----END ED25519 PUBLIC KEY-----\t\"\"\" PKISignatureScheme = \"Ed25519\" LinkPublicKey = \"\"\"-----BEGIN XWING PUBLIC KEY----- TtQkg2XKUnY602FFBaPJ+zpN0Twy20cwyyFxh7FNUjaXA9MAJXs0vUwFbJc6BjYv f+olKnlIKFSmDvcF74U6w1F0ObugwTNKNxeYKPKhX4FiencUbRwkHoYHdtZdSctz TKy08qKQyCAccqCRpdo6ZtYXPAU+2rthjYTOL7Zn+7SHUKCuJClcPnvEYjVcJxtZ ... ubJIe5U4nMJbBkOqr7Kq6niaEkiLODa0tkpB8tKMYTMBdcYyHSXCzpo7U9sb6LAR HktiTBDtRXviu2vbw7VRXhkMW2kjYZDtReQ5sAse04DvmD49zgTp1YxYW+wWFaL3 37X7/SNuLdHX4PHZXIWHBQ== -----END XWING PUBLIC KEY-----\t\"\"\" WireKEMScheme = \"xwing\" Addresses = [\"127.0.0.1:30002\"] [[PKI.dirauth.Authorities]] Identifier = \"auth3\" IdentityPublicKey = \"\"\"-----BEGIN ED25519 PUBLIC KEY----- zQvydRYJq3npeLcg1NqIf+SswEKE5wFmiwNsI9Z1whQ= -----END ED25519 PUBLIC KEY----- \"\"\" PKISignatureScheme = \"Ed25519\" LinkPublicKey = \"\"\" -----BEGIN XWING PUBLIC KEY----- OYK9FiC53xwZ1VST3jDOO4tR+cUMSVRSekmigZMChSjDCPZbKut8TblxtlUfc/yi Ugorz4NIvYPMWUt3QPwS2UWq8/HMWXNGPUiAevg12+oV+jOJXaJeCfY24UekJnSw TNcdGaFZFSR0FocFcPBBnrK1M2B8w8eEUKQIsXRDM3x/8aRIuDif+ve8rSwpgKeh ... OdVD3yw7OOS8uPZLORGQFyJbHtVmFPVvwja4G/o2gntAoHUZ2LiJJakpVhhlSyrI yuzvwwFtZVfWtNb5gAKZCyg0aduR3qgd7MPerRF+YopZk3OCRpC02YxfUZrHv398 FZWJFK0R8iU52CEUxVpXTA== -----END XWING PUBLIC KEY-----\t\"\"\" WireKEMScheme = \"xwing\" Addresses = [\"127.0.0.1:30003\"] Identifier\nSpecifies the human-readable identifier for a node, which must be unique per mixnet. The identifier can be an FQDN but does not have to be.\nType: string\nRequired: Yes\nIdentityPublicKey\nString containing the node's public identity key in PEM format. IdentityPublicKey is the node's permanent identifier and is used to verify cryptographic signatures produced by its private identity key.\nType: string\nRequired: Yes\nPKISignatureScheme\nSpecifies the cryptographic signature scheme that will be used by all components of the mix network when interacting with the PKI system. Mix nodes sign their descriptors using this signature scheme, and dirauth nodes similarly sign PKI documents using the same scheme.\nType: string\nRequired: Yes\nLinkPublicKey\nString containing the peer's public link-layer key in PEM format. LinkPublicKey must match the specified WireKEMScheme.\nType: string\nRequired: Yes\nWireKEMScheme\nThe name of the wire protocol key-encapsulation mechanism (KEM) to use.\nType: string\nRequired: Yes\nAddresses\nSpecifies a list of one or more address URLs in a format that contains the transport protocol, IP address, and port number that the server will bind to for incoming connections. Katzenpost supports URLs that start with either \"tcp://\" or \"quic://\" such as: [\"tcp://192.168.1.1:30001\"] and [\"quic://192.168.1.1:40001\"].\nType: []string\nRequired: Yes\nGateway node: Management section The Management section specifies connectivity information for the Katzenpost control protocol which can be used to make run-time configuration changes. A configuration resembles the following:\n[Management] Enable = false Path = \"/dirauth_mixnet/mix1/management_sock\" Enable\nIf true, the management interface is enabled.\nType: bool\nRequired: No\nPath\nSpecifies the path to the management interface socket. If left empty, then management_sock is located in the configuration's defined DataDir\u003e.\nType: string\nRequired: No\nGateway node: SphinxGeometry section The SphinxGeometry section defines parameters for the Sphinx encrypted nested-packet format used internally by Katzenpost. WarningThe values in the SphinxGeometry configuration section must be programmatically generated by gensphinx. Many of the parameters are interdependent and cannot be individually modified. Do not modify the these values by hand.\nThe settings in this section are generated by the gensphinx utility, which computes the Sphinx geometry based on the following user-supplied directives:\nThe number of mix node layers (not counting gateway and service nodes)\nThe length of the application-usable packet payload\nThe selected NIKE or KEM scheme\nThe output in TOML should then be pasted unchanged into the node's configuration file, as shown below. For more information, see Chapter 4, Appendix: Using gensphinx.\n[SphinxGeometry] PacketLength = 3082 NrHops = 5 HeaderLength = 476 RoutingInfoLength = 410 PerHopRoutingInfoLength = 82 SURBLength = 572 SphinxPlaintextHeaderLength = 2 PayloadTagLength = 32 ForwardPayloadLength = 2574 UserForwardPayloadLength = 2000 NextNodeHopLength = 65 SPRPKeyMaterialLength = 64 NIKEName = \"x25519\" KEMName = \"\" PacketLength\nThe length of a Sphinx packet in bytes.\nType: int\nRequired: Yes\nNrHops\nThe number of hops a Sphinx packet takes through the mixnet. Because packet headers hold destination information for each hop, the size of the header increases linearly with the number of hops.\nType: int\nRequired: Yes\nHeaderLength\nThe total length of the Sphinx packet header in bytes.\nType: int\nRequired: Yes\nRoutingInfoLength\nThe total length of the routing information portion of the Sphinx packet header.\nType: int\nRequired: Yes\nPerHopRoutingInfoLength\nThe length of the per-hop routing information in the Sphinx packet header.\nType: int\nRequired: Yes\nSURBLength\nThe length of a single-use reply block (SURB).\nType: int\nRequired: Yes\nSphinxPlaintextHeaderLength\nThe length of the plaintext Sphinx packet header.\nType: int\nRequired: Yes\nPayloadTagLength\nThe length of the payload tag.\nType: int\nRequired: Yes\nForwardPayloadLength\nThe total size of the payload.\nType: int\nRequired: Yes\nUserForwardPayloadLength\nThe size of the usable payload.\nType: int\nRequired: Yes\nNextNodeHopLength\nThe NextNodeHopLength is derived from the largest routing-information block that we expect to encounter. Other packets have NextNodeHop + NodeDelay sections, or a Recipient section, both of which are shorter.\nType: int\nRequired: Yes\nSPRPKeyMaterialLength\nThe length of the strong pseudo-random permutation (SPRP) key.\nType: int\nRequired: Yes\nNIKEName\nThe name of the non-interactive key exchange (NIKE) scheme used by Sphinx packets.\nNIKEName and KEMName are mutually exclusive.\nType: string\nRequired: Yes\nKEMName\nThe name of the key encapsulation mechanism (KEM) used by Sphinx packets.\nNIKEName and KEMName are mutually exclusive.\nType: string\nRequired: Yes\nGateway node: Debug section The Debug section is the Katzenpost server debug configuration for advanced tuning.\n[Debug] NumSphinxWorkers = 16 NumServiceWorkers = 3 NumGatewayWorkers = 3 NumKaetzchenWorkers = 3 SchedulerExternalMemoryQueue = false SchedulerQueueSize = 0 SchedulerMaxBurst = 16 UnwrapDelay = 250 GatewayDelay = 500 ServiceDelay = 500 KaetzchenDelay = 750 SchedulerSlack = 150 SendSlack = 50 DecoySlack = 15000 ConnectTimeout = 60000 HandshakeTimeout = 30000 ReauthInterval = 30000 SendDecoyTraffic = false DisableRateLimit = false GenerateOnly = false NumSphinxWorkers\nSpecifies the number of worker instances to use for inbound Sphinx packet processing.\nType: int\nRequired: No\nNumProviderWorkers\nSpecifies the number of worker instances to use for provider specific packet processing.\nType: int\nRequired: No\nNumKaetzchenWorkers\nSpecifies the number of worker instances to use for Kaetzchen-specific packet processing.\nType: int\nRequired: No\nSchedulerExternalMemoryQueue\nIf true, the experimental disk-backed external memory queue is enabled.\nType: bool\nRequired: No\nSchedulerQueueSize\nSpecifies the maximum scheduler queue size before random entries will start getting dropped. A value less than or equal to zero is treated as unlimited.\nType: int\nRequired: No\nSchedulerMaxBurst\nSpecifies the maximum number of packets that will be dispatched per scheduler wakeup event.\nType: Required: No\nUnwrapDelay\nSpecifies the maximum unwrap delay due to queueing in milliseconds.\nType: int\nRequired: No\nGatewayDelay\nSpecifies the maximum gateway node worker delay due to queueing in milliseconds.\nType: int\nRequired: No\nServiceDelay\nSpecifies the maximum provider delay due to queueing in milliseconds.\nType: int\nRequired: No\nKaetzchenDelay\nSpecifies the maximum kaetzchen delay due to queueing in milliseconds.\nType: int\nRequired: No\nSchedulerSlack\nSpecifies the maximum scheduler slack due to queueing and/or processing in milliseconds.\nType: int\nRequired: No\nSendSlack\nSpecifies the maximum send-queue slack due to queueing and/or congestion in milliseconds.\nType: int\nRequired: No\nDecoySlack\nSpecifies the maximum decoy sweep slack due to external delays such as latency before a loop decoy packet will be considered lost.\nType: int\nRequired: No\nConnectTimeout\nSpecifies the maximum time a connection can take to establish a TCP/IP connection in milliseconds.\nType: int\nRequired: No\nHandshakeTimeout\nSpecifies the maximum time a connection can take for a link-protocol handshake in milliseconds.\nType: int\nRequired: No\nReauthInterval\nSpecifies the interval at which a connection will be reauthenticated in milliseconds.\nType: int\nRequired: No\nSendDecoyTraffic\nIf true, decoy traffic is enabled. This parameter is experimental and untuned, and is disabled by default.\nNote This option will be removed once decoy traffic is fully implemented.\nType: bool\nRequired: No\nDisableRateLimit\nIf true, the per-client rate limiter is disabled.\nNote This option should only be used for testing.\nType: bool\nRequired: No\nGenerateOnly\nIf true, the server immediately halts and cleans up after long-term key generation.\nType: bool\nRequired: No\nConfiguring service nodes The following configuration is drawn from the reference implementation in katzenpost/docker/dirauth_mixnet/servicenode1/authority.toml. In a real-world mixnet, the component hosts would not be sharing a single IP address. For more information about the test mixnet, see Using the Katzenpost Docker test network.\nTable 1.5. Mix node configuration sections\nService node: Server section\nService node: Logging section\nService node: ServiceNode section\nService node: PKI section\nService node: Management section\nService node: SphinxGeometry section\nService node: Debug section\nService node: Server section The Server section configures mandatory basic parameters for each server node.\n[Server] Identifier = \"servicenode1\" WireKEM = \"xwing\" PKISignatureScheme = \"Ed25519\" Addresses = [\"127.0.0.1:30006\"] OnlyAdvertiseAltAddresses = false MetricsAddress = \"127.0.0.1:30007\" DataDir = \"/dirauth_mixnet/servicenode1\" IsGatewayNode = false IsServiceNode = true [Server.AltAddresses] Identifier\nSpecifies the human-readable identifier for a node, and must be unique per mixnet. The identifier can be an FQDN but does not have to be.\nType: string\nRequired: Yes\nWireKEM\nWireKEM specifies the key encapsulation mechanism (KEM) scheme for the PQ Noise-based wire protocol (link layer) that nodes use to communicate with each other. PQ Noise is a post-quantum variation of the Noise protocol framework, which algebraically transforms ECDH handshake patterns into KEM encapsulate/decapsulate operations.\nThis configuration option supports the optional use of hybrid post-quantum cryptography to strengthen security. The following KEM schemes are supported: Classical: \"x25519\", \"x448\"\nNoteX25519 and X448 are actually non-interactive key-exchanges (NIKEs), not KEMs. Katzenpost uses a Hashed ElGamal cryptographic construction to convert them from NIKEs to KEMs.\nHybrid post-quantum: \"mlkem768\", \"sntrup4591761\", \"frodo640shake\", \"mceliece348864\", \"mceliece348864f\", \"mceliece460896\", \"mceliece460896f\", \"mceliece6688128\", \"mceliece6688128f\", \"mceliece6960119\", \"mceliece6960119f\", \"mceliece8192128\", \"mceliece8192128f\", \"xwing\", \"Kyber768-X25519\", \"MLKEM768-X25519\", \"MLKEM768-X448\", \"CTIDH511\", \"CTIDH512\", \"CTIDH1024\", \"CTIDH2048\", \"CTIDH512-X25519\", \"CTIDH512-X25519\"\nType: string\nRequired: Yes\nPKISignatureScheme\nSpecifies the cryptographic signature scheme that will be used by all components of the mix network when interacting with the PKI system. Mix nodes sign their descriptors using this signature scheme, and dirauth nodes similarly sign PKI documents using the same scheme.\nThe following signature schemes are supported:\nClassical: \"ed25519\", \"ed448\"\nHybrid post-quantum: \"Ed25519 Sphincs+\", \"Ed448-Sphincs+\", \"Ed25519-Dilithium2\", \"Ed448-Dilithium3\" Type: string\nRequired: Yes\nAddresses\nSpecifies a list of one or more address URLs in a format that contains the transport protocol, IP address, and port number that the server will bind to for incoming connections. Katzenpost supports URLs with that start with either \"tcp://\" or \"quic://\" such as: [\"tcp://192.168.1.1:30001\"] and [\"quic://192.168.1.1:40001\"].\nType: []string\nRequired: Yes\nBindAddresses\nIf true, allows setting of listener addresses that the server will bind to and accept connections on. These addresses are not advertised in the PKI.\nType: bool\nRequired: No\nMetricsAddress\nSpecifies the address/port to bind the Prometheus metrics endpoint to.\nType: string\nRequired: No\nDataDir\nSpecifies the absolute path to a node's state directory. This is where persistence.db is written to disk and where a node stores its cryptographic key materials when started with the \"-g\" commmand-line option.\nType: string\nRequired: Yes\nIsGatewayNode\nIf true, the server is a gateway node.\nType: bool\nRequired: No\nIsServiceNode\nIf true, the server is a service node.\nType: bool\nRequired: No\nService node: Logging section The Logging configuration section controls logging behavior across Katzenpost.\n[Logging] Disable = false File = \"katzenpost.log\" Level = \"INFO\" Disable\nIf true, logging is disabled.\nType: bool\nRequired: No\nFile\nSpecifies the log file. If omitted, stdout is used.\nAn absolute or relative file path can be specified. A relative path is relative to the DataDir specified in the Server section of the configuration.\nType: string\nRequired: No\nLevel\nSupported logging level values are ERROR | WARNING | NOTICE |INFO | DEBUG.\nType: string\nRequired: No\nWarning The DEBUG log level is unsafe for production use.\nService node: ServiceNode section The ServiceNode section contains configurations for each network service that Katzenpost supports. Services, termed Kaetzchen, can be divided into built-in and external services. External services are provided through the CBORPlugin, a Go programming language implementation of the Concise Binary Object Representation (CBOR), a binary data serialization format. While native services need simply to be activated, external services are invoked by a separate command and connected to the mixnet over a Unix socket. The plugin allows mixnet services to be added in any programming language.\n[ServiceNode] [[ServiceNode.Kaetzchen]] Capability = \"echo\" Endpoint = \"+echo\" Disable = false [[ServiceNode.CBORPluginKaetzchen]] Capability = \"spool\" Endpoint = \"+spool\" Command = \"/dirauth_mixnet/memspool.alpine\" MaxConcurrency = 1 Disable = false [ServiceNode.CBORPluginKaetzchen.Config] data_store = \"/dirauth_mixnet/servicenode1/memspool.storage\" log_dir = \"/dirauth_mixnet/servicenode1\" [[ServiceNode.CBORPluginKaetzchen]] Capability = \"pigeonhole\" Endpoint = \"+pigeonhole\" Command = \"/dirauth_mixnet/pigeonhole.alpine\" MaxConcurrency = 1 Disable = false [ServiceNode.CBORPluginKaetzchen.Config] db = \"/dirauth_mixnet/servicenode1/map.storage\" log_dir = \"/dirauth_mixnet/servicenode1\" [[ServiceNode.CBORPluginKaetzchen]] Capability = \"panda\" Endpoint = \"+panda\" Command = \"/dirauth_mixnet/panda_server.alpine\" MaxConcurrency = 1 Disable = false [ServiceNode.CBORPluginKaetzchen.Config] fileStore = \"/dirauth_mixnet/servicenode1/panda.storage\" log_dir = \"/dirauth_mixnet/servicenode1\" log_level = \"INFO\" [[ServiceNode.CBORPluginKaetzchen]] Capability = \"http\" Endpoint = \"+http\" Command = \"/dirauth_mixnet/proxy_server.alpine\" MaxConcurrency = 1 Disable = false [ServiceNode.CBORPluginKaetzchen.Config] host = \"localhost:4242\" log_dir = \"/dirauth_mixnet/servicenode1\" log_level = \"DEBUG\" Common parameters:\nCapability\nSpecifies the protocol capability exposed by the agent.\nType: string\nRequired: Yes\nEndpoint\nSpecifies the provider-side Endpoint where the agent will accept requests. While not required by the specification, this server only supports Endpoints that are lower-case local parts of an email address.\nType: string\nRequired: Yes\nCommand\nSpecifies the full path to the external plugin program that implements this Kaetzchen service.\nType: string\nRequired: Yes\nMaxConcurrency\nSpecifies the number of worker goroutines to start for this service.\nType: int\nRequired: Yes\nConfig\nSpecifies extra per-agent arguments to be passed to the agent's initialization routine.\nType: map[string]interface{}\nRequired: Yes\nDisable\nIf true, disables a configured agent.\nType: bool\nRequired: No\nPer-service parameters:\necho\nThe internal echo service must be enabled on every service node of a production mixnet for decoy traffic to work properly. spool\nThe spool service supports the catshadow storage protocol, which is required by the Katzen chat client. The example configuration above shows spool enabled with the setting:\nDisable = falseNote Spool, properly memspool, should not be confused with the spool database on gateway nodes.\ndata_store\nSpecifies the full path to the service database file.\nType: string\nRequired: Yes\nlog_dir\nSpecifies the path to the node's log directory.\nType: string\nRequired: Yes\npigeonhole\nThe pigeonhole courier service supports the Blinding-and-Capability scheme (BACAP)-based unlinkable messaging protocols detailed in Place-holder for research paper link. Most of our future protocols will use the pigeonhole courier service.\ndb\nSpecifies the full path to the service database file.\nType: string\nRequired: Yes\nlog_dir\nSpecifies the path to the node's log directory.\nType: string\nRequired: Yes\npanda\nThe panda storage and authentication service currently does not work properly.\nfileStore\nSpecifies the full path to the service database file.\nType: string\nRequired: Yes\nlog_dir\nSpecifies the path to the node's log directory.\nType: string\nRequired: Yes\nlog_level\nSupported values are ERROR | WARNING | NOTICE |INFO | DEBUG.\nWarning The DEBUG log level is unsafe for production use.\nType: string\nRequired: Yes\nRequired: Yes\nhttp\nThe http service is completely optional, but allows the mixnet to be used as an HTTP proxy. This may be useful for integrating with existing software systems.\nhost\nThe host name and TCP port of the service.\nType: string\nRequired: Yes\nlog_dir\nSpecifies the path to the node's log directory.\nType: string\nRequired: Yes\nlog_level\nSupported values are ERROR | WARNING | NOTICE |INFO | DEBUG.\nType: string\nRequired: Yes\nRequired: Yes\nWarning The DEBUG log level is unsafe for production use.\nType: string\nRequired: Yes\nService node: PKI section The PKI section contains the directory authority configuration for a mix, gateway, or service node.\n[PKI] [PKI.dirauth] [[PKI.dirauth.Authorities]] Identifier = \"auth1\" IdentityPublicKey = \"\"\"-----BEGIN ED25519 PUBLIC KEY----- tqN6tpOVotHWXKCszVn2kS7vAZjQpvJjQF3Qz/Qwhyg= -----END ED25519 PUBLIC KEY----- \"\"\" PKISignatureScheme = \"Ed25519\" LinkPublicKey = \"\"\"-----BEGIN XWING PUBLIC KEY----- JnJ8ztQEIjAkKJcpuZvJAdkWjBim/5G5d8yoosEQHeGJeeBqNPdm2AitUbpiQPcd tNCo9DxuC9Ieqmsfw0YpV6AtOOsaInA6QnHDYcuBfZcQL5MU4+t2TzpBZQYlrSED hPCKrAG+8GEUl6akseG371WQzEtPpEWWCJCJOiS/VDFZT7eKrldlumN6gfiB84sR ... arFh/WKwYJUj+aGBsFYSqGdzC6MdY4x/YyFe2ze0MJEjThQE91y1d/LCQ3Sb7Ri+ u6PBi3JU2qzlPEejDKwK0t5tMNEAkq8iNrpRTdD/hS0gR+ZIN8Z9QKh7Xf94FWG2 H+r8OaqImQhgHabrWRDyLg== -----END XWING PUBLIC KEY----- \"\"\" WireKEMScheme = \"xwing\" Addresses = [\"127.0.0.1:30001\"] [[PKI.dirauth.Authorities]] Identifier = \"auth2\" IdentityPublicKey = \"\"\"-----BEGIN ED25519 PUBLIC KEY----- O51Ty2WLu4C1ETMa29s03bMXV72gnjJfTfwLV++LVBI= -----END ED25519 PUBLIC KEY-----\t\"\"\" PKISignatureScheme = \"Ed25519\" LinkPublicKey = \"\"\"-----BEGIN XWING PUBLIC KEY----- TtQkg2XKUnY602FFBaPJ+zpN0Twy20cwyyFxh7FNUjaXA9MAJXs0vUwFbJc6BjYv f+olKnlIKFSmDvcF74U6w1F0ObugwTNKNxeYKPKhX4FiencUbRwkHoYHdtZdSctz TKy08qKQyCAccqCRpdo6ZtYXPAU+2rthjYTOL7Zn+7SHUKCuJClcPnvEYjVcJxtZ ... ubJIe5U4nMJbBkOqr7Kq6niaEkiLODa0tkpB8tKMYTMBdcYyHSXCzpo7U9sb6LAR HktiTBDtRXviu2vbw7VRXhkMW2kjYZDtReQ5sAse04DvmD49zgTp1YxYW+wWFaL3 37X7/SNuLdHX4PHZXIWHBQ== -----END XWING PUBLIC KEY-----\t\"\"\" WireKEMScheme = \"xwing\" Addresses = [\"127.0.0.1:30002\"] [[PKI.dirauth.Authorities]] Identifier = \"auth3\" IdentityPublicKey = \"\"\"-----BEGIN ED25519 PUBLIC KEY----- zQvydRYJq3npeLcg1NqIf+SswEKE5wFmiwNsI9Z1whQ= -----END ED25519 PUBLIC KEY----- \"\"\" PKISignatureScheme = \"Ed25519\" LinkPublicKey = \"\"\" -----BEGIN XWING PUBLIC KEY----- OYK9FiC53xwZ1VST3jDOO4tR+cUMSVRSekmigZMChSjDCPZbKut8TblxtlUfc/yi Ugorz4NIvYPMWUt3QPwS2UWq8/HMWXNGPUiAevg12+oV+jOJXaJeCfY24UekJnSw TNcdGaFZFSR0FocFcPBBnrK1M2B8w8eEUKQIsXRDM3x/8aRIuDif+ve8rSwpgKeh ... OdVD3yw7OOS8uPZLORGQFyJbHtVmFPVvwja4G/o2gntAoHUZ2LiJJakpVhhlSyrI yuzvwwFtZVfWtNb5gAKZCyg0aduR3qgd7MPerRF+YopZk3OCRpC02YxfUZrHv398 FZWJFK0R8iU52CEUxVpXTA== -----END XWING PUBLIC KEY-----\t\"\"\" WireKEMScheme = \"xwing\" Addresses = [\"127.0.0.1:30003\"] Identifier\nSpecifies the human-readable identifier for a node, which must be unique per mixnet. The identifier can be an FQDN but does not have to be.\nType: string\nRequired: Yes\nIdentityPublicKey\nString containing the node's public identity key in PEM format. IdentityPublicKey is the node's permanent identifier and is used to verify cryptographic signatures produced by its private identity key.\nType: string\nRequired: Yes\nPKISignatureScheme\nSpecifies the cryptographic signature scheme that will be used by all components of the mix network when interacting with the PKI system. Mix nodes sign their descriptors using this signature scheme, and dirauth nodes similarly sign PKI documents using the same scheme.\nType: string\nRequired: Yes\nLinkPublicKey\nString containing the peer's public link-layer key in PEM format. LinkPublicKey must match the specified WireKEMScheme.\nType: string\nRequired: Yes\nWireKEMScheme\nThe name of the wire protocol key-encapsulation mechanism (KEM) to use.\nType: string\nRequired: Yes\nAddresses\nSpecifies a list of one or more address URLs in a format that contains the transport protocol, IP address, and port number that the server will bind to for incoming connections. Katzenpost supports URLs that start with either \"tcp://\" or \"quic://\" such as: [\"tcp://192.168.1.1:30001\"] and [\"quic://192.168.1.1:40001\"].\nType: []string\nRequired: Yes\nService node: Management section The Management section specifies connectivity information for the Katzenpost control protocol which can be used to make run-time configuration changes. A configuration resembles the following:\n[Management] Enable = false Path = \"/dirauth_mixnet/mix1/management_sock\" Enable\nIf true, the management interface is enabled.\nType: bool\nRequired: No\nPath\nSpecifies the path to the management interface socket. If left empty, then management_sock is located in the configuration's defined DataDir\u003e.\nType: string\nRequired: No\nService node: SphinxGeometry section The SphinxGeometry section defines parameters for the Sphinx encrypted nested-packet format used internally by Katzenpost. WarningThe values in the SphinxGeometry configuration section must be programmatically generated by gensphinx. Many of the parameters are interdependent and cannot be individually modified. Do not modify the these values by hand.\nThe settings in this section are generated by the gensphinx utility, which computes the Sphinx geometry based on the following user-supplied directives:\nThe number of mix node layers (not counting gateway and service nodes)\nThe length of the application-usable packet payload\nThe selected NIKE or KEM scheme\nThe output in TOML should then be pasted unchanged into the node's configuration file, as shown below. For more information, see Chapter 4, Appendix: Using gensphinx.\n[SphinxGeometry] PacketLength = 3082 NrHops = 5 HeaderLength = 476 RoutingInfoLength = 410 PerHopRoutingInfoLength = 82 SURBLength = 572 SphinxPlaintextHeaderLength = 2 PayloadTagLength = 32 ForwardPayloadLength = 2574 UserForwardPayloadLength = 2000 NextNodeHopLength = 65 SPRPKeyMaterialLength = 64 NIKEName = \"x25519\" KEMName = \"\" PacketLength\nThe length of a Sphinx packet in bytes.\nType: int\nRequired: Yes\nNrHops\nThe number of hops a Sphinx packet takes through the mixnet. Because packet headers hold destination information for each hop, the size of the header increases linearly with the number of hops.\nType: int\nRequired: Yes\nHeaderLength\nThe total length of the Sphinx packet header in bytes.\nType: int\nRequired: Yes\nRoutingInfoLength\nThe total length of the routing information portion of the Sphinx packet header.\nType: int\nRequired: Yes\nPerHopRoutingInfoLength\nThe length of the per-hop routing information in the Sphinx packet header.\nType: int\nRequired: Yes\nSURBLength\nThe length of a single-use reply block (SURB).\nType: int\nRequired: Yes\nSphinxPlaintextHeaderLength\nThe length of the plaintext Sphinx packet header.\nType: int\nRequired: Yes\nPayloadTagLength\nThe length of the payload tag.\nType: int\nRequired: Yes\nForwardPayloadLength\nThe total size of the payload.\nType: int\nRequired: Yes\nUserForwardPayloadLength\nThe size of the usable payload.\nType: int\nRequired: Yes\nNextNodeHopLength\nThe NextNodeHopLength is derived from the largest routing-information block that we expect to encounter. Other packets have NextNodeHop + NodeDelay sections, or a Recipient section, both of which are shorter.\nType: int\nRequired: Yes\nSPRPKeyMaterialLength\nThe length of the strong pseudo-random permutation (SPRP) key.\nType: int\nRequired: Yes\nNIKEName\nThe name of the non-interactive key exchange (NIKE) scheme used by Sphinx packets.\nNIKEName and KEMName are mutually exclusive.\nType: string\nRequired: Yes\nKEMName\nThe name of the key encapsulation mechanism (KEM) used by Sphinx packets.\nNIKEName and KEMName are mutually exclusive.\nType: string\nRequired: Yes\nService node: Debug section The Debug section is the Katzenpost server debug configuration for advanced tuning.\n[Debug] NumSphinxWorkers = 16 NumServiceWorkers = 3 NumGatewayWorkers = 3 NumKaetzchenWorkers = 3 SchedulerExternalMemoryQueue = false SchedulerQueueSize = 0 SchedulerMaxBurst = 16 UnwrapDelay = 250 GatewayDelay = 500 ServiceDelay = 500 KaetzchenDelay = 750 SchedulerSlack = 150 SendSlack = 50 DecoySlack = 15000 ConnectTimeout = 60000 HandshakeTimeout = 30000 ReauthInterval = 30000 SendDecoyTraffic = false DisableRateLimit = false GenerateOnly = false NumSphinxWorkers\nSpecifies the number of worker instances to use for inbound Sphinx packet processing.\nType: int\nRequired: No\nNumProviderWorkers\nSpecifies the number of worker instances to use for provider specific packet processing.\nType: int\nRequired: No\nNumKaetzchenWorkers\nSpecifies the number of worker instances to use for Kaetzchen-specific packet processing.\nType: int\nRequired: No\nSchedulerExternalMemoryQueue\nIf true, the experimental disk-backed external memory queue is enabled.\nType: bool\nRequired: No\nSchedulerQueueSize\nSpecifies the maximum scheduler queue size before random entries will start getting dropped. A value less than or equal to zero is treated as unlimited.\nType: int\nRequired: No\nSchedulerMaxBurst\nSpecifies the maximum number of packets that will be dispatched per scheduler wakeup event.\nType: Required: No\nUnwrapDelay\nSpecifies the maximum unwrap delay due to queueing in milliseconds.\nType: int\nRequired: No\nGatewayDelay\nSpecifies the maximum gateway node worker delay due to queueing in milliseconds.\nType: int\nRequired: No\nServiceDelay\nSpecifies the maximum provider delay due to queueing in milliseconds.\nType: int\nRequired: No\nKaetzchenDelay\nSpecifies the maximum kaetzchen delay due to queueing in milliseconds.\nType: int\nRequired: No\nSchedulerSlack\nSpecifies the maximum scheduler slack due to queueing and/or processing in milliseconds.\nType: int\nRequired: No\nSendSlack\nSpecifies the maximum send-queue slack due to queueing and/or congestion in milliseconds.\nType: int\nRequired: No\nDecoySlack\nSpecifies the maximum decoy sweep slack due to external delays such as latency before a loop decoy packet will be considered lost.\nType: int\nRequired: No\nConnectTimeout\nSpecifies the maximum time a connection can take to establish a TCP/IP connection in milliseconds.\nType: int\nRequired: No\nHandshakeTimeout\nSpecifies the maximum time a connection can take for a link-protocol handshake in milliseconds.\nType: int\nRequired: No\nReauthInterval\nSpecifies the interval at which a connection will be reauthenticated in milliseconds.\nType: int\nRequired: No\nSendDecoyTraffic\nIf true, decoy traffic is enabled. This parameter is experimental and untuned, and is disabled by default.\nNote This option will be removed once decoy traffic is fully implemented.\nType: bool\nRequired: No\nDisableRateLimit\nIf true, the per-client rate limiter is disabled.\nNote This option should only be used for testing.\nType: bool\nRequired: No\nGenerateOnly\nIf true, the server immediately halts and cleans up after long-term key generation.\nType: bool\nRequired: No\nChapter 2. Using the Katzenpost Docker test networkTable of Contents\nRequirementsPreparing to run the container imageOperating the test mixnetStarting and monitoring the mixnetTesting the mixnetShutting down the mixnetUninstalling and cleaning upNetwork topology and componentsThe Docker file tree Katzenpost provides a ready-to-deploy Docker image for developers who need a non-production test environment for developing and testing client applications and server side plugins. By running this image on a single computer, you avoid the need to build and manage a complex multi-node mix net. The image can also be run using Podman\nThe test mix network includes the following components:\nThree directory authority (PKI) nodes\nSix mix nodes, including one node serving also as both gateway and service provider\nA ping utility, run-ping\nRequirements Before running the Katzenpost docker image, make sure that the following software is installed. A Debian GNU Linux or Ubuntu system\nGit\nGo\nGNU Make\nPrometheus\nDocker, Docker Compose, and (optionally) Podman\nNote If both Docker and Podman are present on your system, Katzenpost uses Podman. Podman is a drop-in daemonless equivalent to Docker that does not require superuser privileges to run.\nOn Debian, these software requirements can be installed with the following commands (running as superuser). Apt will pull in the needed dependencies.\n# apt update # apt install git golang make docker docker-compose podman Preparing to run the container image Complete the following procedure to obtain, build, and deploy the Katzenpost test network. Install the Katzenpost code repository, hosted at https://github.com/katzenpost. The main Katzenpost repository contains code for the server components as well as the docker image. Clone the repository with the following command (your directory location may vary):\n~$ git clone https://github.com/katzenpost/katzenpost.git Navigate to the new katzenpost subdirectory and ensure that the code is up to date. ~$ cd katzenpost ~/katzenpost$ git checkout main ~/katzenpost$ git pull (Optional) Create a development branch and check it out.\n~/katzenpost$ git checkout -b devel (Optional) If you are using Podman, complete the following steps:\nPoint the DOCKER_HOST environment variable at the Podman process.\n$ export DOCKER_HOST=unix:///var/run/user/$(id -u)/podman/podman.sock Set up and start the Podman server (as superuser).\n$ podman system service -t 0 $DOCKER_HOST \u0026 $ systemctl --user enable --now podman.socket Operating the test mixnet Navigate to katzenpost/docker. The Makefile contains target operations to create, manage, and test the self-contained Katzenpost container network. To invoke a target, run a command with the using the following pattern:\n~/katzenpost/docker$ make target Running make with no target specified returns a list of available targets.\nTable 2.1. Table 1: Makefile targets\n[none]\nDisplay this list of targets.\nstart\nRun the test network in the background.\nstop\nStop the test network.\nwait\nWait for the test network to have consensus.\nwatch Display live log entries until Ctrl-C.\nstatus\nShow test network consensus status.\nshow-latest-vote\nShow latest consensus vote.\nrun-ping\nSend a ping over the test network. clean-bin\nStop all components and delete binaries.\nclean-local\nStop all components, delete binaries, and delete data.\nclean-local-dryrun\nShow what clean-local would delete.\nclean\nSame as clean-local, but also deletes go_deps image.\nStarting and monitoring the mixnet The first time that you run make start, the Docker image is downloaded, built, installed, and started. This takes several minutes. When the build is complete, the command exits while the network remains running in the background.\n~/katzenpost/docker$ make start Subsequent runs of make start either start or restart the network without building the components from scratch. The exception to this is when you delete any of the Katzenpost binaries (dirauth.alpine, server.alpine, etc.). In that case, make start rebuilds just the parts of the network dependent on the deleted binary. For more information about the files created during the Docker build, see the section called “Network topology and components”.\nNote When running make start , be aware of the following considerations:\nIf you intend to use Docker, you need to run make as superuser. If you are using sudo to elevate your privileges, you need to edit katzenpost/docker/Makefile to prepend sudo to each command contained in it.\nIf you have Podman installed on your system and you nonetheless want to run Docker, you can override the default behavior by adding the argument docker=docker to the command as in the following:\n~/katzenpost/docker$ make run docker=docker After the make start command exits, the mixnet runs in the background, and you can run make watch to display a live log of the network activity.\n~/katzenpost/docker$ make watch ... \u003coutput\u003e ... When installation is complete, the mix servers vote and reach a consensus. You can use the wait target to wait for the mixnet to get consensus and be ready to use. This can also take several minutes:\n~/katzenpost/docker$ make wait ... \u003coutput\u003e ... You can confirm that installation and configuration are complete by issuing the status command from the same or another terminal. When the network is ready for use, status begins returning consensus information similar to the following:\n~/katzenpost/docker$ make status ... 00:15:15.003 NOTI state: Consensus made for epoch 1851128 with 3/3 signatures: \u0026{Epoch: 1851128 GenesisEpoch: 1851118 ... Testing the mixnet At this point, you should have a locally running mix network. You can test whether it is working correctly by using run-ping, which launches a packet into the network and watches for a successful reply. Run the following command:\n~/katzenpost/docker$ make run-ping If the network is functioning properly, the resulting output contains lines similar to the following:\n19:29:53.541 INFO gateway1_client: sending loop decoy !19:29:54.108 INFO gateway1_client: sending loop decoy 19:29:54.632 INFO gateway1_client: sending loop decoy 19:29:55.160 INFO gateway1_client: sending loop decoy !19:29:56.071 INFO gateway1_client: sending loop decoy !19:29:59.173 INFO gateway1_client: sending loop decoy !Success rate is 100.000000 percent 10/10) lf run-ping fails to receive a reply, it eventually times out with an error message. If this happens, try the command again. Note If you attempt use run-ping too quickly after starting the mixnet, and consensus has not been reached, the utility may crash with an error message or hang indefinitely. If this happens, issue (if necessary) a Ctrl-C key sequence to abort, check the consensus status with the status command, and then retry run-ping.\nShutting down the mixnet The mix network continues to run in the terminal where you started it until you issue a Ctrl-C key sequence, or until you issue the following command in another terminal:\n~/katzenpost/docker$ make stop When you stop the network, the binaries and data are left in place. This allows for a quick restart.\nUninstalling and cleaning up Several command targets can be used to uninstall the Docker image and restore your system to a clean state. The following examples demonstrate the commands and their output.\nclean-bin\nTo stop the network and delete the compiled binaries, run the following command:\n~/katzenpost/docker$ make clean-bin [ -e voting_mixnet ] \u0026\u0026 cd voting_mixnet \u0026\u0026 DOCKER_HOST=unix:///run/user/1000/podman/podman.sock docker-compose down --remove-orphans; rm -fv running.stamp Stopping voting_mixnet_auth3_1 ... done Stopping voting_mixnet_servicenode1_1 ... done Stopping voting_mixnet_metrics_1 ... done Stopping voting_mixnet_mix3_1 ... done Stopping voting_mixnet_auth2_1 ... done Stopping voting_mixnet_mix2_1 ... done Stopping voting_mixnet_gateway1_1 ... done Stopping voting_mixnet_auth1_1 ... done Stopping voting_mixnet_mix1_1 ... done Removing voting_mixnet_auth3_1 ... done Removing voting_mixnet_servicenode1_1 ... done Removing voting_mixnet_metrics_1 ... done Removing voting_mixnet_mix3_1 ... done Removing voting_mixnet_auth2_1 ... done Removing voting_mixnet_mix2_1 ... done Removing voting_mixnet_gateway1_1 ... done Removing voting_mixnet_auth1_1 ... done Removing voting_mixnet_mix1_1 ... done removed 'running.stamp' rm -vf ./voting_mixnet/*.alpine removed './voting_mixnet/echo_server.alpine' removed './voting_mixnet/fetch.alpine' removed './voting_mixnet/memspool.alpine' removed './voting_mixnet/panda_server.alpine' removed './voting_mixnet/pigeonhole.alpine' removed './voting_mixnet/ping.alpine' removed './voting_mixnet/reunion_katzenpost_server.alpine' removed './voting_mixnet/server.alpine' removed './voting_mixnet/voting.alpine' This command leaves in place the cryptographic keys, the state data, and the logs.\nclean-local-dryrun\nTo diplay a preview of what clean-local would remove, without actually deleting anything, run the following command:\n~/katzenpost/docker$ make clean-local-dryrun clean-local\nTo delete both compiled binaries and data, run the following command:\n~/katzenpost/docker$ make clean-local [ -e voting_mixnet ] \u0026\u0026 cd voting_mixnet \u0026\u0026 DOCKER_HOST=unix:///run/user/1000/podman/podman.sock docker-compose down --remove-orphans; rm -fv running.stamp Removing voting_mixnet_mix2_1 ... done Removing voting_mixnet_auth1_1 ... done Removing voting_mixnet_auth2_1 ... done Removing voting_mixnet_gateway1_1 ... done Removing voting_mixnet_mix1_1 ... done Removing voting_mixnet_auth3_1 ... done Removing voting_mixnet_mix3_1 ... done Removing voting_mixnet_servicenode1_1 ... done Removing voting_mixnet_metrics_1 ... done removed 'running.stamp' rm -vf ./voting_mixnet/*.alpine removed './voting_mixnet/echo_server.alpine' removed './voting_mixnet/fetch.alpine' removed './voting_mixnet/memspool.alpine' removed './voting_mixnet/panda_server.alpine' removed './voting_mixnet/pigeonhole.alpine' removed './voting_mixnet/reunion_katzenpost_server.alpine' removed './voting_mixnet/server.alpine' removed './voting_mixnet/voting.alpine' git clean -f -x voting_mixnet Removing voting_mixnet/ git status . On branch main Your branch is up to date with 'origin/main'. clean\nTo stop the the network and delete the binaries, the data, and the go_deps image, run the following command as superuser: ~/katzenpost/docker$ sudo make clean Network topology and components The Docker image deploys a working mixnet with all components and component groups needed to perform essential mixnet functions: message mixing (including packet reordering, timing randomization, injection of decoy traffic, obfuscation of senders and receivers, and so on)\nservice provisioning\ninternal authentication and integrity monitoring\ninterfacing with external clients\nWarning While suited for client development and testing, the test mixnet omits performance and security redundancies. Do not use it in production.\nThe following diagram illustrates the components and their network interactions. The gray blocks represent nodes, and the arrows represent information transfer. Figure 2.1. Test network topology\nOn the left, the Client transmits a message (shown by purple arrows) through the Gateway node, across three mix node layers, to the Service node. The Service node processes the request and responds with a reply (shown by the green arrows) that traverses the mix node layers before exiting the mixnet via the Gateway node and arriving at the Client.\nOn the right, directory authorities Dirauth 1, Dirauth 2, and Dirauth 3 provide PKI services. The directory authorities receive mix descriptors from the other nodes, collate these into a consensus document containing validated network status and authentication materials , and make that available to the other nodes. The elements in the topology diagram map to the mixnet's component nodes as shown in the following table. Note that all nodes share the same IP address (127.0.0.1, i.e., localhost), but are accessed through different ports. Each node type links to additional information in Components and configuration of the Katzenpost mixnet.\nTable 2.2. Table 2: Test mixnet hosts\nNode typeDocker IDDiagram labelIP addressTCP port Directory authority\nauth1Dirauth1 127.0.0.1 (localhost)\n30001\nauth2\nDirauth 2 30002\nauth3\nDirauth 3 30003\nGateway nodegateway1Gateway node30004 Service node\nservicenode1\nService node 30006 Mix node\nmix1\nLayer 1 mix node 30008\nmix2\nLayer 2 mix node 30010\nmix3\nLayer 3 mix node 30012\nThe Docker file tree The following tree output shows the location, relative to the katzenpost repository root, of the files created by the Docker build. During testing and use, you would normally touch only the TOML configuration file associated with each node, as highlighted in the listing. For help in understanding these files and a complete list of configuration options, follow the links in Table 2: Test mixnet hosts.\nkatzenpost/docker/voting_mixnet/ |---auth1 |   |---authority.toml |   |---identity.private.pem |   |---identity.public.pem |   |---katzenpost.log |   |---link.private.pem |   |---link.public.pem |   |---persistence.db |---auth2 |   |---authority.toml |   |---identity.private.pem |   |---identity.public.pem |   |---katzenpost.log |   |---link.private.pem |   |---link.public.pem |   |---persistence.db |---auth3 |   |---authority.toml |   |---identity.private.pem |   |---identity.public.pem |   |---katzenpost.log |   |---link.private.pem |   |---link.public.pem |   |---persistence.db |---client |   |---client.toml |---client2 |   |---client.toml |---dirauth.alpine |---docker-compose.yml |---echo_server.alpine |---fetch.alpine |---gateway1 |   |---identity.private.pem |   |---identity.public.pem |   |---katzenpost.log |   |---katzenpost.toml |   |---link.private.pem |   |---link.public.pem |   |---management_sock |   |---spool.db |   |---users.db |---memspool.alpine |---mix1 |   |---identity.private.pem |   |---identity.public.pem |   |---katzenpost.log |   |---katzenpost.toml |   |---link.private.pem |   |---link.public.pem |---mix2 |   |---identity.private.pem |   |---identity.public.pem |   |---katzenpost.log |   |---katzenpost.toml |   |---link.private.pem |   |---link.public.pem |---mix3 |   |---identity.private.pem |   |---identity.public.pem |   |---katzenpost.log |   |---katzenpost.toml |   |---link.private.pem |   |---link.public.pem |---panda_server.alpine |---pigeonhole.alpine |---ping.alpine |---prometheus.yml |---proxy_client.alpine |---proxy_server.alpine |---running.stamp |---server.alpine |---servicenode1 |   |---identity.private.pem |   |---identity.public.pem |   |---katzenpost.log |   |---katzenpost.toml |   |---link.private.pem |   |---link.public.pem |   |---management_sock |   |---map.storage |   |---memspool.13.log |   |---memspool.storage |   |---panda.25.log |   |---panda.storage |   |---pigeonHole.19.log |   |---proxy.31.log |---voting_mixnet Examples of complete TOML configuration files are provided in Appendix: Configuration files from the Docker test mixnet .\nChapter 3. Appendix: Configuration files from the Docker test mixnet Table of Contents\nDirectory authorityMix nodeGateway nodeService node As an aid to adminstrators implementing a Katzenpost mixnet, this appendix provides lightly edited examples of configuration files for each Katzenpost node type. These files are drawn from a built instance of the Docker test mixnet. These code listings are meant to be used as a reference alongside the detailed configuration documentation in Chapter 1, Components and configuration of the Katzenpost mixnet. You cannot use these listings as a drop-in solution in your own mixnets for reasons explained in the the section called “Network topology and components” section of the Docker test mixnet documentation.\nDirectory authority Source: ../katzenpost/docker/voting_mixnet/auth1/authority.toml\n[Server] Identifier = \"auth1\" WireKEMScheme = \"xwing\" PKISignatureScheme = \"Ed448-Dilithium3\" Addresses = [\"tcp://127.0.0.1:30001\"] DataDir = \"/voting_mixnet/auth1\" [[Authorities]] Identifier = \"auth1\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\nfvcvAfUpeu7lMHjQBw [...] Gpi8ovBXl9ENIHLwA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\nsxxS04mftoEmwjxE/w [...] expP2fbERpGQwVNg==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30001\"] [[Authorities]] Identifier = \"auth2\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\n5nsy6uFQ1782fZ+iYn [...] Sdr2xoinylYJr/3AA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\nkQzCJvaS6jg06szLea [...] PG1Bzx1JwHGFxRBQ==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30002\"] [[Authorities]] Identifier = \"auth3\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\nJzkFpS035de1PmA2MM [...] jo6Z7is9GLs0YxVQA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\n+pIUsgEGwHa8k4GZcb [...] 1mxoc+4kcgZWuOAg==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30003\"] [Logging] Disable = false File = \"katzenpost.log\" Level = \"INFO\" [Parameters] SendRatePerMinute = 0 Mu = 0.005 MuMaxDelay = 1000 LambdaP = 0.001 LambdaPMaxDelay = 1000 LambdaL = 0.0005 LambdaLMaxDelay = 1000 LambdaD = 0.0005 LambdaDMaxDelay = 3000 LambdaM = 0.0005 LambdaG = 0.0 LambdaMMaxDelay = 100 LambdaGMaxDelay = 100 [Debug] Layers = 3 MinNodesPerLayer = 1 GenerateOnly = false [[Mixes]] Identifier = \"mix1\" IdentityPublicKeyPem = \"../mix1/identity.public.pem\" [[Mixes]] Identifier = \"mix2\" IdentityPublicKeyPem = \"../mix2/identity.public.pem\" [[Mixes]] Identifier = \"mix3\" IdentityPublicKeyPem = \"../mix3/identity.public.pem\" [[GatewayNodes]] Identifier = \"gateway1\" IdentityPublicKeyPem = \"../gateway1/identity.public.pem\" [[ServiceNodes]] Identifier = \"servicenode1\" IdentityPublicKeyPem = \"../servicenode1/identity.public.pem\" [Topology] [[Topology.Layers]] [[Topology.Layers.Nodes]] Identifier = \"mix1\" IdentityPublicKeyPem = \"../mix1/identity.public.pem\" [[Topology.Layers]] [[Topology.Layers.Nodes]] Identifier = \"mix2\" IdentityPublicKeyPem = \"../mix2/identity.public.pem\" [[Topology.Layers]] [[Topology.Layers.Nodes]] Identifier = \"mix3\" IdentityPublicKeyPem = \"../mix3/identity.public.pem\" [SphinxGeometry] PacketLength = 3082 NrHops = 5 HeaderLength = 476 RoutingInfoLength = 410 PerHopRoutingInfoLength = 82 SURBLength = 572 SphinxPlaintextHeaderLength = 2 PayloadTagLength = 32 ForwardPayloadLength = 2574 UserForwardPayloadLength = 2000 NextNodeHopLength = 65 SPRPKeyMaterialLength = 64 NIKEName = \"x25519\" KEMName = \"\" Mix node Source: ../katzenpost/docker/voting_mixnet/mix1/katzenpost.toml\n[Server] Identifier = \"mix1\" WireKEM = \"xwing\" PKISignatureScheme = \"Ed448-Dilithium3\" Addresses = [\"tcp://127.0.0.1:30010\", \"quic://[::1]:30011\"] MetricsAddress = \"127.0.0.1:30012\" DataDir = \"/voting_mixnet/mix1\" IsGatewayNode = false IsServiceNode = false [Logging] Disable = false File = \"katzenpost.log\" Level = \"INFO\" [PKI] [PKI.Voting] [[PKI.Voting.Authorities]] Identifier = \"auth1\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\nfvcvAfUpeu7lMHjQBw [...] Gpi8ovBXl9ENIHLwA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\nsxxS04mftoEmwjxE/w [...] expP2fbERpGQwVNg==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30001\"] [[PKI.Voting.Authorities]] Identifier = \"auth2\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\n5nsy6uFQ1782fZ+iYn [...] Sdr2xoinylYJr/3AA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\nkQzCJvaS6jg06szLea [...] PG1Bzx1JwHGFxRBQ==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30002\"] [[PKI.Voting.Authorities]] Identifier = \"auth3\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\nJzkFpS035de1PmA2M [...] jo6Z7is9GLs0YxVQA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\n+pIUsgEGwHa8k4GZcb [...] 1mxoc+4kcgZWuOAg==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30003\"] [Management] Enable = false Path = \"/voting_mixnet/mix1/management_sock\" [SphinxGeometry] PacketLength = 3082 NrHops = 5 HeaderLength = 476 RoutingInfoLength = 410 PerHopRoutingInfoLength = 82 SURBLength = 572 SphinxPlaintextHeaderLength = 2 PayloadTagLength = 32 ForwardPayloadLength = 2574 UserForwardPayloadLength = 2000 NextNodeHopLength = 65 SPRPKeyMaterialLength = 64 NIKEName = \"x25519\" KEMName = \"\" [Debug] NumSphinxWorkers = 16 NumServiceWorkers = 3 NumGatewayWorkers = 3 NumKaetzchenWorkers = 3 SchedulerExternalMemoryQueue = false SchedulerQueueSize = 0 SchedulerMaxBurst = 16 UnwrapDelay = 250 GatewayDelay = 500 ServiceDelay = 500 KaetzchenDelay = 750 SchedulerSlack = 150 SendSlack = 50 DecoySlack = 15000 ConnectTimeout = 60000 HandshakeTimeout = 30000 ReauthInterval = 30000 SendDecoyTraffic = false DisableRateLimit = false GenerateOnly = false Gateway node Source: ../katzenpost/docker/voting_mixnet/gateway1/katzenpost.toml\n[Server] Identifier = \"gateway1\" WireKEM = \"xwing\" PKISignatureScheme = \"Ed448-Dilithium3\" Addresses = [\"tcp://127.0.0.1:30004\", \"quic://[::1]:30005\", \"onion://thisisjustatestoniontoverifythatconfigandpkiworkproperly.onion:4242\"] BindAddresses = [\"tcp://127.0.0.1:30004\", \"quic://[::1]:30005\"] MetricsAddress = \"127.0.0.1:30006\" DataDir = \"/voting_mixnet/gateway1\" IsGatewayNode = true IsServiceNode = false [Logging] Disable = false File = \"katzenpost.log\" Level = \"INFO\" [Gateway] [Gateway.UserDB] Backend = \"bolt\" [Gateway.UserDB.Bolt] UserDB = \"/voting_mixnet/gateway1/users.db\" [Gateway.SpoolDB] Backend = \"bolt\" [Gateway.SpoolDB.Bolt] SpoolDB = \"/voting_mixnet/gateway1/spool.db\" [PKI] [PKI.Voting] [[PKI.Voting.Authorities]] Identifier = \"auth1\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\nfvcvAfUpeu7lMHjQBw [...] Gpi8ovBXl9ENIHLwA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\nsxxS04mftoEmwjxE/w [...] expP2fbERpGQwVNg==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30001\"] [[PKI.Voting.Authorities]] Identifier = \"auth2\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\n5nsy6uFQ1782fZ+iYn [...] Sdr2xoinylYJr/3AA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\nkQzCJvaS6jg06szLea [...] PG1Bzx1JwHGFxRBQ==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30002\"] [[PKI.Voting.Authorities]] Identifier = \"auth3\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\nJzkFpS035de1PmA2MM [...] jo6Z7is9GLs0YxVQA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\n+pIUsgEGwHa8k4GZcb [...] 1mxoc+4kcgZWuOAg==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30003\"] [Management] Enable = true Path = \"/voting_mixnet/gateway1/management_sock\" [SphinxGeometry] PacketLength = 3082 NrHops = 5 HeaderLength = 476 RoutingInfoLength = 410 PerHopRoutingInfoLength = 82 SURBLength = 572 SphinxPlaintextHeaderLength = 2 PayloadTagLength = 32 ForwardPayloadLength = 2574 UserForwardPayloadLength = 2000 NextNodeHopLength = 65 SPRPKeyMaterialLength = 64 NIKEName = \"x25519\" KEMName = \"\" [Debug] NumSphinxWorkers = 16 NumServiceWorkers = 3 NumGatewayWorkers = 3 NumKaetzchenWorkers = 3 SchedulerExternalMemoryQueue = false SchedulerQueueSize = 0 SchedulerMaxBurst = 16 UnwrapDelay = 250 GatewayDelay = 500 ServiceDelay = 500 KaetzchenDelay = 750 SchedulerSlack = 150 SendSlack = 50 DecoySlack = 15000 ConnectTimeout = 60000 HandshakeTimeout = 30000 ReauthInterval = 30000 SendDecoyTraffic = false DisableRateLimit = false GenerateOnly = false Service node Source: ../katzenpost/docker/voting_mixnet/servicenode1/katzenpost.toml\n[Server] Identifier = \"servicenode1\" WireKEM = \"xwing\" PKISignatureScheme = \"Ed448-Dilithium3\" Addresses = [\"tcp://127.0.0.1:30007\", \"quic://[::1]:30008\"] MetricsAddress = \"127.0.0.1:30009\" DataDir = \"/voting_mixnet/servicenode1\" IsGatewayNode = false IsServiceNode = true [Logging] Disable = false File = \"katzenpost.log\" Level = \"INFO\" [ServiceNode] [[ServiceNode.Kaetzchen]] Capability = \"echo\" Endpoint = \"+echo\" Disable = false [[ServiceNode.Kaetzchen]] Capability = \"testdest\" Endpoint = \"+testdest\" Disable = false [[ServiceNode.CBORPluginKaetzchen]] Capability = \"spool\" Endpoint = \"+spool\" Command = \"/voting_mixnet/memspool.alpine\" MaxConcurrency = 1 Disable = false [ServiceNode.CBORPluginKaetzchen.Config] data_store = \"/voting_mixnet/servicenode1/memspool.storage\" log_dir = \"/voting_mixnet/servicenode1\" [[ServiceNode.CBORPluginKaetzchen]] Capability = \"pigeonhole\" Endpoint = \"+pigeonhole\" Command = \"/voting_mixnet/pigeonhole.alpine\" MaxConcurrency = 1 Disable = false [ServiceNode.CBORPluginKaetzchen.Config] db = \"/voting_mixnet/servicenode1/map.storage\" log_dir = \"/voting_mixnet/servicenode1\" [[ServiceNode.CBORPluginKaetzchen]] Capability = \"panda\" Endpoint = \"+panda\" Command = \"/voting_mixnet/panda_server.alpine\" MaxConcurrency = 1 Disable = false [ServiceNode.CBORPluginKaetzchen.Config] fileStore = \"/voting_mixnet/servicenode1/panda.storage\" log_dir = \"/voting_mixnet/servicenode1\" log_level = \"INFO\" [[ServiceNode.CBORPluginKaetzchen]] Capability = \"http\" Endpoint = \"+http\" Command = \"/voting_mixnet/proxy_server.alpine\" MaxConcurrency = 1 Disable = false [ServiceNode.CBORPluginKaetzchen.Config] host = \"localhost:4242\" log_dir = \"/voting_mixnet/servicenode1\" log_level = \"DEBUG\" [PKI] [PKI.Voting] [[PKI.Voting.Authorities]] Identifier = \"auth1\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\nfvcvAfUpeu7lMHjQBw [...] Gpi8ovBXl9ENIHLwA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\nsxxS04mftoEmwjxE/w [...] expP2fbERpGQwVNg==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30001\"] [[PKI.Voting.Authorities]] Identifier = \"auth2\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\n5nsy6uFQ1782fZ+iYn [...] Sdr2xoinylYJr/3AA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\nkQzCJvaS6jg06szLea [...] PG1Bzx1JwHGFxRBQ==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30002\"] [[PKI.Voting.Authorities]] Identifier = \"auth3\" IdentityPublicKey = \"-----BEGIN ED448-DILITHIUM3 PUBLIC KEY-----\\nJzkFpS035de1PmA2MM [...] jo6Z7is9GLs0YxVQA=\\n-----END ED448-DILITHIUM3 PUBLIC KEY-----\\n\" PKISignatureScheme = \"Ed448-Dilithium3\" LinkPublicKey = \"-----BEGIN XWING PUBLIC KEY-----\\n+pIUsgEGwHa8k4GZcb [...] 1mxoc+4kcgZWuOAg==\\n-----END XWING PUBLIC KEY-----\\n\" WireKEMScheme = \"xwing\" Addresses = [\"tcp://127.0.0.1:30003\"] [Management] Enable = true Path = \"/voting_mixnet/servicenode1/management_sock\" [SphinxGeometry] PacketLength = 3082 NrHops = 5 HeaderLength = 476 RoutingInfoLength = 410 PerHopRoutingInfoLength = 82 SURBLength = 572 SphinxPlaintextHeaderLength = 2 PayloadTagLength = 32 ForwardPayloadLength = 2574 UserForwardPayloadLength = 2000 NextNodeHopLength = 65 SPRPKeyMaterialLength = 64 NIKEName = \"x25519\" KEMName = \"\" [Debug] NumSphinxWorkers = 16 NumServiceWorkers = 3 NumGatewayWorkers = 3 NumKaetzchenWorkers = 4 SchedulerExternalMemoryQueue = false SchedulerQueueSize = 0 SchedulerMaxBurst = 16 UnwrapDelay = 250 GatewayDelay = 500 ServiceDelay = 500 KaetzchenDelay = 750 SchedulerSlack = 150 SendSlack = 50 DecoySlack = 15000 ConnectTimeout = 60000 HandshakeTimeout = 30000 ReauthInterval = 30000 SendDecoyTraffic = false DisableRateLimit = false GenerateOnly = false Chapter 4. Appendix: Using gensphinx To Do\n","categories":"","description":"","excerpt":" Katzenpost administrator's guideKatzenpost administrator's guideTable …","ref":"/pages/admin_guide/","tags":"","title":"Admin Guide"},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/false/","tags":"","title":"False"},{"body":" Katzenpost, the first post quantum mixnet. Katzenpost is an educational, research and free software project. We make anonymous communication protocols, specializing in mixnet protocols.\nPresentations Browse recent and past video/audio presentations about Katzenpost and mixnets designs.\nRead more\nKatzenpost Admin Guide Read our extensive documentation for a better understanding of the Katzenpost server side. NOTE that this document also covers how to run a local docker mixnet which is useful for developers.\nRead more\nKatzenpost Threat Model Here we present a draft of the Katzenpost mixnet threat model document. We regard the threat model document as a living document which is frequently edited and in need of ongoing maintenance as we continue to develop newer mixnet protocols.\nRead more\nKatzenpost Literature Review This doc, in particular, does not talk about the Katzenpost design. It does introduce the reader to some of the reasons why we’ve been making certain design decisions, and a keen eye might be led to some of the similar conclusions. But here we focus on already published research. We also stick to theory and don’t focus on any practical systems being built today.\nRead more\nOur Team Our team consists of world class experts.\nRead more\nsource code Find our source code on github.\nRead more\n","categories":"","description":"Katzenpost is a free and open source software project.","excerpt":"Katzenpost is a free and open source software project.","ref":"/","tags":"","title":"Katzenpost"},{"body":" ","categories":"","description":"","excerpt":" ","ref":"/admin/","tags":"","title":"Katzenpost CMS"},{"body":"","categories":"","description":"","excerpt":"","ref":"/pages/","tags":"","title":"Pages"},{"body":"Videos Dr. Eva Infeld and Leif Ryge: project status session at Chaos Communication Congress, 37c3 David Stainton: BornHack 2018 - Modern Mix Network Design YouTube Jeff Burdges and David Stainton 34C3 - Practical Mix Network Design YouTube David Stainton: Anonymizing Cryptocurrencies from Network Observers with Mix Networks YouTube David Stainton Shows How Mix Networks Improve Privacy YouTube Slides David Stainton: Modern Mix Network Design (2017/12) PDF Moritz Bartl: Anonymität im Internet (German) (2017/12) PDF ODP Claudia Diaz, Moritz Bartl: Katzenpost Mix Network (2018/09) PDF ODP ","categories":"","description":"","excerpt":"Videos Dr. Eva Infeld and Leif Ryge: project status session at Chaos …","ref":"/pages/presentations/","tags":"","title":"Presentations"},{"body":"Given that our team hails from various sects in the vanguard of online privacy and anonymity research and our mission is to create anonymizing mixnet technology, we want to know as little about the people interacting with our website as possible.\nIt is our promise that you will find absolutely zero browser based tracking with session cookies, browser dBs, nor any fingerprinting techniques on our websites.\nGitHub\nCurrently, this website maintained by the Katzenpost team is served via GitHub Pages. You may read their lengthy and lawyerly privacy policy here.\n","categories":"","description":"","excerpt":"Given that our team hails from various sects in the vanguard of online …","ref":"/pages/privacy/","tags":"","title":"Privacy Policy"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tango/","tags":"","title":"Tango"},{"body":" Current Team David Stainton Researcher \u0026 developer\n@david415 on masala Developer \u0026 protocol design\n@mixmasala on Leif Ryge Developer \u0026 protocol design\n@leif on Dr. Eva Infeld Research and evaluation\n@evainfeld on threebithacker Developer\n@threebithacker on David Robinson, Ph.D. Technical writer\n@jdormansteele on John Brown Advisory \u0026 fundraising\nContributors yippyskippy Brett Preston Past Contributors The current Katzenpost project was formerly referred to as the Panoramix Project which was under development from 2015 until Jan 2019. This included the following contributors, some of whom are still working on other mixnetworks.\nResearch George Danezis Claudia Diaz Ania Piotrowska Advice Nick Mathewson Trevor Perrin Miscellaneous Ura Design Development Yawning Angel Moritz Bartl Sofía Celi Mikerah Vincent Breitmoser Kali meskio In memory of Andreas Pfitzmann Len Sassaman ","categories":"","description":"","excerpt":" Current Team David Stainton Researcher \u0026 developer\n@david415 on …","ref":"/pages/pages/team/","tags":"","title":"Katzenpost Team"},{"body":"","categories":"","description":"","excerpt":"","ref":"/true/","tags":"","title":"True"},{"body":"The Moral Character of Cryptographic Work December 2015, Philip Rogaway\n“Cryptography rearranges power: it configures who can do what, from what. This makes cryptography an inherently political tool, and it confers on the field an intrinsically moral dimension. The Snowden revelations motivate a reassessment of the political and moral positioning of cryptography. They lead one to ask if our inability to effectively address mass surveillance constitutes a failure of our field. I believe that it does. I call for a community-wide effort to develop more effective means to resist mass surveillance. I plead for a reinvention of our disciplinary culture to attend not only to puzzles and math, but, also, to the societal implications of our work.” ~Philip Rogaway\nSource and links 25th Usenix Security Symposium presentation Selected Quotes “Still more ostensibly political is David Chaum’s body of scientific work, which thoroughly embeds concerns for democracy and individual autonomy. Chaum’s 1981 paper “Untraceable Electronic Mail, Return Addresses, and Digital Pseudonyms”, suggests that a crucial privacy goal when sending an email is to hide who is communicating with whom. The metadata, in modern political parlance. The author offered mix nets for a solution.”\n“An especially problematic excision of the political is the marginalization within the cryptographic community of the secure-messaging problem, an instance of which was the problem addressed by Chaum. Secure-messaging is the most fundamental privacy problem in cryptography: how can parties communicate in such a way that nobody knows who said what. More than a decade after the problem was introduced, Rackoff and Simon would comment on the near-absence of attention being paid to it.”\n“Another 20-plus years later, the situation is this: there is now a mountain of work on secure-messaging, but it’s unclear what most of it actually does. A recent systemization-of-knowledge article paints a picture of a cryptographic task enjoying a flourishing of ad hoc solutions, but little of it arising from the cryptographic community, as narrowly construed, or tied to much theory. While one could certainly claim that this is true for almost all practical security goals that employ cryptography, I think the case is different for secure-messaging: here the work feels almost intentionally pushed aside.”\nLaw Enforcement Framing vs. Surveillance Framing\nConsider the following way to frame mass surveillance, which follows often-heard thoughts from cypherpunks and surveillance studies.\nSurveillance is an instrument of power. It is part of an apparatus of control. Power need not be in-your-face to be effective: subtle, psychological, nearly invisible methods can actually be more effective.\nWhile surveillance is nothing new, technological changes have given governments and corporations an unprecedented capacity to monitor everyone’s communication and movement. Surveilling everyone has became cheaper than figuring out whom to surveil, and the marginal cost is now tiny. The Internet, once seen by many as a tool for emancipation, is being transformed into the most dangerous facilitator for totalitarianism ever seen. Governmental surveillance is strongly linked to cyberwar. Security vulnerabilities that enable one enable the other. And, at least in the USA, the same individuals and agencies handle both jobs. Surveillance is also strongly linked to conventional warfare. As Gen. Michael Hayden has explained, “we kill people based on metadata.” surveillance and assassination by drones are one technological ecosystem.\nThe law-enforcement narrative is wrong to position privacy as an individual good when it is, just as much, a social good. It is equally wrong to regard privacy and security as conflicting values, as privacy enhances security as often as it rubs against it.\nMass surveillance will tend to produce uniform, compliant, and shallow people It will thwart or reverse social progress. In a world of ubiquitous monitoring, there is no space for personal exploration, and no space to challenge social norms, either. Living in fear, there is no genuine freedom.\nBut creeping surveillance is hard to stop, because of interlocking corporate and governmental interests. Cryptography offers at least some hope. With it, one might carve out a space free of power’s reach.\"\n","categories":"","description":"Why we started creating Katzenpost and what principles guide us.","excerpt":"Why we started creating Katzenpost and what principles guide us.","ref":"/pages/moral-character/","tags":"","title":"Katzenpost Politics and Values"}]